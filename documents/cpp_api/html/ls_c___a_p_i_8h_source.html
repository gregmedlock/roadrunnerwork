<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>RoadRunner C++ API: R:/roadrunnerwork/trunk/source/libstruct/lsC_API.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">RoadRunner C++ API
   &#160;<span id="projectnumber">1.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">R:/roadrunnerwork/trunk/source/libstruct/lsC_API.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="ls_c___a_p_i_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef lsC_APIH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define lsC_APIH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="comment">//---------------------------------------------------------------------------</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment"></span><span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">//#if defined(__cplusplus)</span>
<a name="l00008"></a>00008 <span class="comment">//#  define BEGIN_C_DECLS extern &quot;C&quot; { //</span>
<a name="l00009"></a>00009 <span class="comment">//#  define END_C_DECLS   } //</span>
<a name="l00010"></a>00010 <span class="comment">//#else</span>
<a name="l00011"></a>00011 <span class="comment">//#  define BEGIN_C_DECLS</span>
<a name="l00012"></a>00012 <span class="comment">//#  define END_C_DECLS</span>
<a name="l00013"></a>00013 <span class="comment">//#endif</span>
<a name="l00014"></a>00014 <span class="comment">//</span>
<a name="l00015"></a>00015 <span class="comment">//BEGIN_C_DECLS;</span>
<a name="l00016"></a>00016 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment"></span><span class="comment">//</span>
<a name="l00019"></a>00019 <span class="comment">//Loads the stoichiometry matrix into the library. To analyze the stoichiometry</span>
<a name="l00020"></a>00020 <span class="comment">//call one of the following:</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">//\li ::LibStructural_analyzeWithQR,</span>
<a name="l00023"></a>00023 <span class="comment">//\li ::LibStructural_analyzeWithLU,</span>
<a name="l00024"></a>00024 <span class="comment">//\li ::LibStructural_analyzeWithLUandRunTests,</span>
<a name="l00025"></a>00025 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLU or</span>
<a name="l00026"></a>00026 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLUwithTests</span>
<a name="l00027"></a>00027 <span class="comment">//</span>
<a name="l00028"></a>00028 <span class="comment">//</span>
<a name="l00029"></a>00029 <span class="comment">//\remarks if matrix labels are needed it is recommended to call</span>
<a name="l00030"></a>00030 <span class="comment">//::LibStructural_loadSpecies and ::LibStructural_loadReactionNames after</span>
<a name="l00031"></a>00031 <span class="comment">//a call to this function.</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="comment">//\param oMatrix a pointer to a double** matrix</span>
<a name="l00034"></a>00034 <span class="comment">//\param nRows the number of rows of the matrix</span>
<a name="l00035"></a>00035 <span class="comment">//\param nCols the number of columns of the matrix</span>
<a name="l00036"></a>00036 <span class="comment">//</span>
<a name="l00037"></a>00037 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00038"></a>00038 <span class="comment">//an error occurred</span>
<a name="l00039"></a>00039 <span class="comment">//*/</span>
<a name="l00040"></a>00040 <span class="comment">//  int LibStructural_loadStoichiometryMatrix (const double ** oMatrix, const int nRows, const int nCols);</span>
<a name="l00042"></a>00042 <span class="comment"></span><span class="comment">//This is an example of how to load a (unlabeled) stoichiometry matrix and read test details.</span>
<a name="l00043"></a>00043 <span class="comment">//*/</span>
<a name="l00044"></a>00044 <span class="comment">//</span>
<a name="l00046"></a>00046 <span class="comment"></span><span class="comment">//This is an example of how to load a labeled stoichiometry matrix and read test results.</span>
<a name="l00047"></a>00047 <span class="comment">//The example also shows how to print the reordered stoichiometry matrix as well as the</span>
<a name="l00048"></a>00048 <span class="comment">//Gamma matrix.</span>
<a name="l00049"></a>00049 <span class="comment">//*/</span>
<a name="l00050"></a>00050 <span class="comment">//</span>
<a name="l00052"></a>00052 <span class="comment"></span><span class="comment">//This is an example of how to load a SBML file and print structural analysis test results.</span>
<a name="l00053"></a>00053 <span class="comment">//*/</span>
<a name="l00054"></a>00054 <span class="comment">//</span>
<a name="l00056"></a>00056 <span class="comment"></span><span class="comment">//</span>
<a name="l00057"></a>00057 <span class="comment">//This function should be used whenever labeled matrices are important as these</span>
<a name="l00058"></a>00058 <span class="comment">//labels will be used in labeling the structural matrices. This function sets the species</span>
<a name="l00059"></a>00059 <span class="comment">//names (ids). It is also possible to provide an initial condition for each of</span>
<a name="l00060"></a>00060 <span class="comment">//the species. This will be used when calculating the conserved sums.</span>
<a name="l00061"></a>00061 <span class="comment">//</span>
<a name="l00062"></a>00062 <span class="comment">//\param speciesNames an array of strings of species names with length nLength</span>
<a name="l00063"></a>00063 <span class="comment">//\param speciesValues an array of real numbers of species concentrations corresponding</span>
<a name="l00064"></a>00064 <span class="comment">//to the speciesName with the same index</span>
<a name="l00065"></a>00065 <span class="comment">//\param nLength number of elements in speciesNames and speciesValues</span>
<a name="l00066"></a>00066 <span class="comment">//</span>
<a name="l00067"></a>00067 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00068"></a>00068 <span class="comment">//an error occurred</span>
<a name="l00069"></a>00069 <span class="comment">//</span>
<a name="l00070"></a>00070 <span class="comment">//\remarks This method should only be called after ::LibStructural_loadStoichiometryMatrix</span>
<a name="l00071"></a>00071 <span class="comment">//</span>
<a name="l00072"></a>00072 <span class="comment">//*/</span>
<a name="l00073"></a>00073 <span class="comment">//  int LibStructural_loadSpecies ( const char** speciesNames, const double* speciesValues, const int nLength);</span>
<a name="l00074"></a>00074 <span class="comment">//</span>
<a name="l00076"></a>00076 <span class="comment"></span><span class="comment">//</span>
<a name="l00077"></a>00077 <span class="comment">//This function should be used whenever labeled matrices are important as these</span>
<a name="l00078"></a>00078 <span class="comment">//labels will be used in labeling the structural matrices. This function sets the reaction</span>
<a name="l00079"></a>00079 <span class="comment">//names (ids).</span>
<a name="l00080"></a>00080 <span class="comment">//</span>
<a name="l00081"></a>00081 <span class="comment">//\param reactionNames an array of strings of reaction names with length nLength</span>
<a name="l00082"></a>00082 <span class="comment">//\param nLength number of elements in reactionNames</span>
<a name="l00083"></a>00083 <span class="comment">//</span>
<a name="l00084"></a>00084 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00085"></a>00085 <span class="comment">//an error occurred</span>
<a name="l00086"></a>00086 <span class="comment">//</span>
<a name="l00087"></a>00087 <span class="comment">//\remarks This method should only be called after ::LibStructural_loadStoichiometryMatrix</span>
<a name="l00088"></a>00088 <span class="comment">//</span>
<a name="l00089"></a>00089 <span class="comment">//*/</span>
<a name="l00090"></a>00090 <span class="comment">//#ifndef NO_SBML</span>
<a name="l00091"></a>00091 <span class="comment">//</span>
<a name="l00092"></a>00092 <span class="comment">//  int LibStructural_loadReactionNames ( const char** reactionNames, const int nLength);</span>
<a name="l00093"></a>00093 <span class="comment">//</span>
<a name="l00095"></a>00095 <span class="comment"></span><span class="comment">//\param sSBML the SBML string to load into the library</span>
<a name="l00096"></a>00096 <span class="comment">//\param outMessage a pointer to a string that the library can use to provide information</span>
<a name="l00097"></a>00097 <span class="comment">//about the loaded SBML</span>
<a name="l00098"></a>00098 <span class="comment">//\param nLength is the length of the above message</span>
<a name="l00099"></a>00099 <span class="comment">//</span>
<a name="l00100"></a>00100 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00101"></a>00101 <span class="comment">//an error occurred (invalid SBML)</span>
<a name="l00102"></a>00102 <span class="comment">//</span>
<a name="l00103"></a>00103 <span class="comment">//*/</span>
<a name="l00104"></a>00104 <span class="comment">//  int LibStructural_loadSBML(const char* sSBML, char* *outMessage, int *nLength);</span>
<a name="l00105"></a>00105 <span class="comment">//</span>
<a name="l00107"></a>00107 <span class="comment"></span><span class="comment">//\param sFileName the full path to the SBML file to be loaded.</span>
<a name="l00108"></a>00108 <span class="comment">//\param outMessage a pointer to a string that the library can use to provide information</span>
<a name="l00109"></a>00109 <span class="comment">//about the loaded SBML</span>
<a name="l00110"></a>00110 <span class="comment">//\param nLength is the length of the above message</span>
<a name="l00111"></a>00111 <span class="comment">//</span>
<a name="l00112"></a>00112 <span class="comment">//\remarks To avoid unintentional errors be sure to pass in the full path to the SBML file.</span>
<a name="l00113"></a>00113 <span class="comment">//</span>
<a name="l00114"></a>00114 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00115"></a>00115 <span class="comment">//an error occurred (invalid SBML, file not readable ...).</span>
<a name="l00116"></a>00116 <span class="comment">//</span>
<a name="l00117"></a>00117 <span class="comment">//*/</span>
<a name="l00118"></a>00118 <span class="comment">//  int LibStructural_loadSBMLFromFile(const char* sFileName, char* *outMessage, int *nLength);</span>
<a name="l00119"></a>00119 <span class="comment">//</span>
<a name="l00121"></a>00121 <span class="comment"></span><span class="comment">//\param sSBML the SBML string to load into the library</span>
<a name="l00122"></a>00122 <span class="comment">//\param outMessage a pointer to a string that contains information about the loaded</span>
<a name="l00123"></a>00123 <span class="comment">//model as well as the test results of the internal test suite.</span>
<a name="l00124"></a>00124 <span class="comment">//\param nLength is the length of the above message</span>
<a name="l00125"></a>00125 <span class="comment">//</span>
<a name="l00126"></a>00126 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00127"></a>00127 <span class="comment">//an error occurred (invalid SBML)</span>
<a name="l00128"></a>00128 <span class="comment">//</span>
<a name="l00129"></a>00129 <span class="comment">//*/</span>
<a name="l00130"></a>00130 <span class="comment">//  int LibStructural_loadSBMLwithTests(const char* sSBML, char* *outMessage, int *nLength);</span>
<a name="l00131"></a>00131 <span class="comment">//#endif</span>
<a name="l00133"></a>00133 <span class="comment"></span><span class="comment">//</span>
<a name="l00134"></a>00134 <span class="comment">//This method performs the actual analysis of the stoichiometry matrix (loaded either</span>
<a name="l00135"></a>00135 <span class="comment">//via ::LibStructural_loadStoichiometryMatrix or ::LibStructural_loadSBML. Only after</span>
<a name="l00136"></a>00136 <span class="comment">//one of the analysis methods below has been called are the structural matrices (L0, K0...)</span>
<a name="l00137"></a>00137 <span class="comment">//available.</span>
<a name="l00138"></a>00138 <span class="comment">//</span>
<a name="l00139"></a>00139 <span class="comment">//\li ::LibStructural_analyzeWithQR,</span>
<a name="l00140"></a>00140 <span class="comment">//\li ::LibStructural_analyzeWithLU,</span>
<a name="l00141"></a>00141 <span class="comment">//\li ::LibStructural_analyzeWithLUandRunTests,</span>
<a name="l00142"></a>00142 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLU or</span>
<a name="l00143"></a>00143 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLUwithTests</span>
<a name="l00144"></a>00144 <span class="comment">//</span>
<a name="l00145"></a>00145 <span class="comment">//</span>
<a name="l00146"></a>00146 <span class="comment">//\remarks This is the prefered method for structural analysis.</span>
<a name="l00147"></a>00147 <span class="comment">//</span>
<a name="l00148"></a>00148 <span class="comment">//\param outMessage a pointer to a string where status information of the analysis</span>
<a name="l00149"></a>00149 <span class="comment">//will be returned.</span>
<a name="l00150"></a>00150 <span class="comment">//\param nLength the length of the message.</span>
<a name="l00151"></a>00151 <span class="comment">//</span>
<a name="l00152"></a>00152 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00153"></a>00153 <span class="comment">//no stoichiometry matrix was loaded beforehand see ::LibStructural_loadStoichiometryMatrix</span>
<a name="l00154"></a>00154 <span class="comment">//or ::LibStructural_loadSBML or ::LibStructural_loadSBMLFromFile</span>
<a name="l00155"></a>00155 <span class="comment">//</span>
<a name="l00156"></a>00156 <span class="comment">//*/</span>
<a name="l00157"></a>00157 <span class="comment">//  int LibStructural_analyzeWithQR(char* *outMessage, int *nLength);</span>
<a name="l00159"></a>00159 <span class="comment"></span><span class="comment">//</span>
<a name="l00160"></a>00160 <span class="comment">//This method performs the actual analysis of the stoichiometry matrix (loaded either</span>
<a name="l00161"></a>00161 <span class="comment">//via ::LibStructural_loadStoichiometryMatrix or ::LibStructural_loadSBML. Only after</span>
<a name="l00162"></a>00162 <span class="comment">//one of the analysis methods below has been called are the structural matrices (L0, K0...)</span>
<a name="l00163"></a>00163 <span class="comment">//available.</span>
<a name="l00164"></a>00164 <span class="comment">//</span>
<a name="l00165"></a>00165 <span class="comment">//\li ::LibStructural_analyzeWithQR,</span>
<a name="l00166"></a>00166 <span class="comment">//\li ::LibStructural_analyzeWithLU,</span>
<a name="l00167"></a>00167 <span class="comment">//\li ::LibStructural_analyzeWithLUandRunTests,</span>
<a name="l00168"></a>00168 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLU or</span>
<a name="l00169"></a>00169 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLUwithTests</span>
<a name="l00170"></a>00170 <span class="comment">//</span>
<a name="l00171"></a>00171 <span class="comment">//</span>
<a name="l00172"></a>00172 <span class="comment">//\param outMessage a pointer to a string where status information of the analysis</span>
<a name="l00173"></a>00173 <span class="comment">//will be returned.</span>
<a name="l00174"></a>00174 <span class="comment">//\param nLength the length of the message.</span>
<a name="l00175"></a>00175 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00176"></a>00176 <span class="comment">//no stoichiometry matrix was loaded beforehand see ::LibStructural_loadStoichiometryMatrix</span>
<a name="l00177"></a>00177 <span class="comment">//or ::LibStructural_loadSBML or ::LibStructural_loadSBMLFromFile</span>
<a name="l00178"></a>00178 <span class="comment">//*/</span>
<a name="l00179"></a>00179 <span class="comment">//  int LibStructural_analyzeWithLU(char* *outMessage, int *nLength);</span>
<a name="l00181"></a>00181 <span class="comment"></span><span class="comment">//</span>
<a name="l00182"></a>00182 <span class="comment">//This method performs the actual analysis of the stoichiometry matrix (loaded either</span>
<a name="l00183"></a>00183 <span class="comment">//via ::LibStructural_loadStoichiometryMatrix or ::LibStructural_loadSBML. Only after</span>
<a name="l00184"></a>00184 <span class="comment">//one of the analysis methods below has been called are the structural matrices (L0, K0...)</span>
<a name="l00185"></a>00185 <span class="comment">//available.</span>
<a name="l00186"></a>00186 <span class="comment">//</span>
<a name="l00187"></a>00187 <span class="comment">//\li ::LibStructural_analyzeWithQR,</span>
<a name="l00188"></a>00188 <span class="comment">//\li ::LibStructural_analyzeWithLU,</span>
<a name="l00189"></a>00189 <span class="comment">//\li ::LibStructural_analyzeWithLUandRunTests,</span>
<a name="l00190"></a>00190 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLU or</span>
<a name="l00191"></a>00191 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLUwithTests</span>
<a name="l00192"></a>00192 <span class="comment">//</span>
<a name="l00193"></a>00193 <span class="comment">//</span>
<a name="l00194"></a>00194 <span class="comment">//This method additionally performs the integrated test suite and returns    those results.</span>
<a name="l00195"></a>00195 <span class="comment">//</span>
<a name="l00196"></a>00196 <span class="comment">//\param outMessage a pointer to a string where status information of the analysis</span>
<a name="l00197"></a>00197 <span class="comment">//will be returned.</span>
<a name="l00198"></a>00198 <span class="comment">//\param nLength the length of the message.</span>
<a name="l00199"></a>00199 <span class="comment">//</span>
<a name="l00200"></a>00200 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00201"></a>00201 <span class="comment">//no stoichiometry matrix was loaded beforehand see ::LibStructural_loadStoichiometryMatrix</span>
<a name="l00202"></a>00202 <span class="comment">//or ::LibStructural_loadSBML or ::LibStructural_loadSBMLFromFile</span>
<a name="l00203"></a>00203 <span class="comment">//</span>
<a name="l00204"></a>00204 <span class="comment">//*/</span>
<a name="l00205"></a>00205 <span class="comment">//  int LibStructural_analyzeWithLUandRunTests(char* *outMessage, int *nLength);</span>
<a name="l00207"></a>00207 <span class="comment"></span><span class="comment">//</span>
<a name="l00208"></a>00208 <span class="comment">//This method performs the actual analysis of the stoichiometry matrix (loaded either</span>
<a name="l00209"></a>00209 <span class="comment">//via ::LibStructural_loadStoichiometryMatrix or ::LibStructural_loadSBML. Only after</span>
<a name="l00210"></a>00210 <span class="comment">//one of the analysis methods below has been called are the structural matrices (L0, K0...)</span>
<a name="l00211"></a>00211 <span class="comment">//available.</span>
<a name="l00212"></a>00212 <span class="comment">//</span>
<a name="l00213"></a>00213 <span class="comment">//\li ::LibStructural_analyzeWithQR,</span>
<a name="l00214"></a>00214 <span class="comment">//\li ::LibStructural_analyzeWithLU,</span>
<a name="l00215"></a>00215 <span class="comment">//\li ::LibStructural_analyzeWithLUandRunTests,</span>
<a name="l00216"></a>00216 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLU or</span>
<a name="l00217"></a>00217 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLUwithTests</span>
<a name="l00218"></a>00218 <span class="comment">//</span>
<a name="l00219"></a>00219 <span class="comment">//\remarks Unlike the other methods, this method handles only square stoichiometry</span>
<a name="l00220"></a>00220 <span class="comment">//matrices. This method was only included for backward compatibility use</span>
<a name="l00221"></a>00221 <span class="comment">//::LibStructural_analyzeWithQR</span>
<a name="l00222"></a>00222 <span class="comment">//</span>
<a name="l00223"></a>00223 <span class="comment">//\param outMessage a pointer to a string where status information of the analysis</span>
<a name="l00224"></a>00224 <span class="comment">//will be returned.</span>
<a name="l00225"></a>00225 <span class="comment">//\param nLength the length of the message.</span>
<a name="l00226"></a>00226 <span class="comment">//</span>
<a name="l00227"></a>00227 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00228"></a>00228 <span class="comment">//no stoichiometry matrix was loaded beforehand. See ::LibStructural_loadStoichiometryMatrix</span>
<a name="l00229"></a>00229 <span class="comment">//or ::LibStructural_loadSBML or ::LibStructural_loadSBMLFromFile</span>
<a name="l00230"></a>00230 <span class="comment">//*/</span>
<a name="l00231"></a>00231 <span class="comment">//  int LibStructural_analyzeWithFullyPivotedLU(char* *outMessage, int *nLength);</span>
<a name="l00233"></a>00233 <span class="comment"></span><span class="comment">//</span>
<a name="l00234"></a>00234 <span class="comment">//This method performs the actual analysis of the stoichiometry matrix (loaded either</span>
<a name="l00235"></a>00235 <span class="comment">//via ::LibStructural_loadStoichiometryMatrix or ::LibStructural_loadSBML. Only after</span>
<a name="l00236"></a>00236 <span class="comment">//one of the analysis methods below has been called are the structural matrices (L0, K0...)</span>
<a name="l00237"></a>00237 <span class="comment">//available.</span>
<a name="l00238"></a>00238 <span class="comment">//</span>
<a name="l00239"></a>00239 <span class="comment">//\li ::LibStructural_analyzeWithQR,</span>
<a name="l00240"></a>00240 <span class="comment">//\li ::LibStructural_analyzeWithLU,</span>
<a name="l00241"></a>00241 <span class="comment">//\li ::LibStructural_analyzeWithLUandRunTests,</span>
<a name="l00242"></a>00242 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLU or</span>
<a name="l00243"></a>00243 <span class="comment">//\li ::LibStructural_analyzeWithFullyPivotedLUwithTests</span>
<a name="l00244"></a>00244 <span class="comment">//</span>
<a name="l00245"></a>00245 <span class="comment">//</span>
<a name="l00246"></a>00246 <span class="comment">//This method additionally performs the integrated test suite and returns those results.</span>
<a name="l00247"></a>00247 <span class="comment">//</span>
<a name="l00248"></a>00248 <span class="comment">//\remarks Unlike the other methods, this method handles only square stoichiometry</span>
<a name="l00249"></a>00249 <span class="comment">//matrices. For non-square matrices use a method like ::LibStructural_analyzeWithQR.</span>
<a name="l00250"></a>00250 <span class="comment">//</span>
<a name="l00251"></a>00251 <span class="comment">//\param outMessage a pointer to a string where status information of the analysis</span>
<a name="l00252"></a>00252 <span class="comment">//will be returned.</span>
<a name="l00253"></a>00253 <span class="comment">//\param nLength the length of the message.</span>
<a name="l00254"></a>00254 <span class="comment">//</span>
<a name="l00255"></a>00255 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00256"></a>00256 <span class="comment">//no stoichiometry matrix was loaded beforehand see ::LibStructural_loadStoichiometryMatrix</span>
<a name="l00257"></a>00257 <span class="comment">//or ::LibStructural_loadSBML or ::LibStructural_loadSBMLFromFile</span>
<a name="l00258"></a>00258 <span class="comment">//*/</span>
<a name="l00259"></a>00259 <span class="comment">//  int LibStructural_analyzeWithFullyPivotedLUwithTests(char* *outMessage, int *nLength);</span>
<a name="l00260"></a>00260 <span class="comment">//</span>
<a name="l00262"></a>00262 <span class="comment"></span><span class="comment">//</span>
<a name="l00263"></a>00263 <span class="comment">//L0 is defined such that  L0 Nr = N0. L0 forms part of the link matrix, L.  N0 is the set of</span>
<a name="l00264"></a>00264 <span class="comment">//linear dependent rows from the lower portion of the reordered stoichiometry matrix.</span>
<a name="l00265"></a>00265 <span class="comment">//</span>
<a name="l00266"></a>00266 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00267"></a>00267 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00268"></a>00268 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00269"></a>00269 <span class="comment">//</span>
<a name="l00270"></a>00270 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00271"></a>00271 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods have</span>
<a name="l00272"></a>00272 <span class="comment">//been called yet.</span>
<a name="l00273"></a>00273 <span class="comment">//</span>
<a name="l00274"></a>00274 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00275"></a>00275 <span class="comment">//and outRows as parameter.</span>
<a name="l00276"></a>00276 <span class="comment">//*/</span>
<a name="l00277"></a>00277 <span class="comment">//  int LibStructural_getL0Matrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00278"></a>00278 <span class="comment">//</span>
<a name="l00280"></a>00280 <span class="comment"></span><span class="comment">//</span>
<a name="l00281"></a>00281 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00282"></a>00282 <span class="comment">//and written.</span>
<a name="l00283"></a>00283 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00284"></a>00284 <span class="comment">//returned.</span>
<a name="l00285"></a>00285 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00286"></a>00286 <span class="comment">//and written.</span>
<a name="l00287"></a>00287 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00288"></a>00288 <span class="comment">//returned.</span>
<a name="l00289"></a>00289 <span class="comment">//</span>
<a name="l00290"></a>00290 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00291"></a>00291 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00292"></a>00292 <span class="comment">//been called yet.</span>
<a name="l00293"></a>00293 <span class="comment">//</span>
<a name="l00294"></a>00294 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00295"></a>00295 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00296"></a>00296 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00297"></a>00297 <span class="comment">//*/</span>
<a name="l00298"></a>00298 <span class="comment">//  int LibStructural_getL0MatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00299"></a>00299 <span class="comment">//                                                char** *outColLabels, int *outColCount);</span>
<a name="l00300"></a>00300 <span class="comment">//</span>
<a name="l00302"></a>00302 <span class="comment"></span><span class="comment">//The rows of the Nr matrix will be linearly independent.</span>
<a name="l00303"></a>00303 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00304"></a>00304 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00305"></a>00305 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00306"></a>00306 <span class="comment">//</span>
<a name="l00307"></a>00307 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00308"></a>00308 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00309"></a>00309 <span class="comment">//been called yet.</span>
<a name="l00310"></a>00310 <span class="comment">//</span>
<a name="l00311"></a>00311 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00312"></a>00312 <span class="comment">//and outRows as parameter.</span>
<a name="l00313"></a>00313 <span class="comment">//*/</span>
<a name="l00314"></a>00314 <span class="comment">//  int LibStructural_getNrMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00316"></a>00316 <span class="comment"></span><span class="comment">//</span>
<a name="l00317"></a>00317 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00318"></a>00318 <span class="comment">//and written.</span>
<a name="l00319"></a>00319 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00320"></a>00320 <span class="comment">//returned.</span>
<a name="l00321"></a>00321 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00322"></a>00322 <span class="comment">//and written.</span>
<a name="l00323"></a>00323 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00324"></a>00324 <span class="comment">//returned.</span>
<a name="l00325"></a>00325 <span class="comment">//</span>
<a name="l00326"></a>00326 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00327"></a>00327 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00328"></a>00328 <span class="comment">//been called yet.</span>
<a name="l00329"></a>00329 <span class="comment">//</span>
<a name="l00330"></a>00330 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00331"></a>00331 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00332"></a>00332 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00333"></a>00333 <span class="comment">//*/</span>
<a name="l00334"></a>00334 <span class="comment">//  int LibStructural_getNrMatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00335"></a>00335 <span class="comment">//                                                char** *outColLabels, int *outColCount);</span>
<a name="l00336"></a>00336 <span class="comment">//</span>
<a name="l00338"></a>00338 <span class="comment"></span><span class="comment">//</span>
<a name="l00339"></a>00339 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00340"></a>00340 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00341"></a>00341 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00342"></a>00342 <span class="comment">//</span>
<a name="l00343"></a>00343 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00344"></a>00344 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00345"></a>00345 <span class="comment">//been called yet.</span>
<a name="l00346"></a>00346 <span class="comment">//</span>
<a name="l00347"></a>00347 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00348"></a>00348 <span class="comment">//and outRows as parameter.</span>
<a name="l00349"></a>00349 <span class="comment">//*/</span>
<a name="l00350"></a>00350 <span class="comment">//  int LibStructural_getColumnReorderedNrMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00352"></a>00352 <span class="comment"></span><span class="comment">//</span>
<a name="l00353"></a>00353 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00354"></a>00354 <span class="comment">//and written.</span>
<a name="l00355"></a>00355 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00356"></a>00356 <span class="comment">//returned.</span>
<a name="l00357"></a>00357 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00358"></a>00358 <span class="comment">//and written.</span>
<a name="l00359"></a>00359 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00360"></a>00360 <span class="comment">//returned.</span>
<a name="l00361"></a>00361 <span class="comment">//</span>
<a name="l00362"></a>00362 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00363"></a>00363 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00364"></a>00364 <span class="comment">//been called yet.</span>
<a name="l00365"></a>00365 <span class="comment">//</span>
<a name="l00366"></a>00366 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00367"></a>00367 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00368"></a>00368 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00369"></a>00369 <span class="comment">//*/</span>
<a name="l00370"></a>00370 <span class="comment">//  int LibStructural_getColumnReorderedNrMatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00371"></a>00371 <span class="comment">//                                                               char** *outColLabels, int *outColCount);</span>
<a name="l00372"></a>00372 <span class="comment">//</span>
<a name="l00374"></a>00374 <span class="comment"></span><span class="comment">//</span>
<a name="l00375"></a>00375 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00376"></a>00376 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00377"></a>00377 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00378"></a>00378 <span class="comment">//</span>
<a name="l00379"></a>00379 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00380"></a>00380 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00381"></a>00381 <span class="comment">//been called yet.</span>
<a name="l00382"></a>00382 <span class="comment">//</span>
<a name="l00383"></a>00383 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00384"></a>00384 <span class="comment">//and outRows as parameter.</span>
<a name="l00385"></a>00385 <span class="comment">//*/</span>
<a name="l00386"></a>00386 <span class="comment">//  int LibStructural_getNICMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00388"></a>00388 <span class="comment"></span><span class="comment">//</span>
<a name="l00389"></a>00389 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00390"></a>00390 <span class="comment">//and written.</span>
<a name="l00391"></a>00391 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00392"></a>00392 <span class="comment">//returned.</span>
<a name="l00393"></a>00393 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00394"></a>00394 <span class="comment">//and written.</span>
<a name="l00395"></a>00395 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00396"></a>00396 <span class="comment">//returned.</span>
<a name="l00397"></a>00397 <span class="comment">//</span>
<a name="l00398"></a>00398 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00399"></a>00399 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00400"></a>00400 <span class="comment">//been called yet.</span>
<a name="l00401"></a>00401 <span class="comment">//</span>
<a name="l00402"></a>00402 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00403"></a>00403 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00404"></a>00404 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00405"></a>00405 <span class="comment">//*/</span>
<a name="l00406"></a>00406 <span class="comment">//  int LibStructural_getNICMatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00407"></a>00407 <span class="comment">//                                                 char** *outColLabels, int *outColCount);</span>
<a name="l00409"></a>00409 <span class="comment"></span><span class="comment">//</span>
<a name="l00410"></a>00410 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00411"></a>00411 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00412"></a>00412 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00413"></a>00413 <span class="comment">//</span>
<a name="l00414"></a>00414 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00415"></a>00415 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00416"></a>00416 <span class="comment">//been called yet.</span>
<a name="l00417"></a>00417 <span class="comment">//</span>
<a name="l00418"></a>00418 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00419"></a>00419 <span class="comment">//and outRows as parameter.</span>
<a name="l00420"></a>00420 <span class="comment">//*/</span>
<a name="l00421"></a>00421 <span class="comment">//  int LibStructural_getNDCMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00423"></a>00423 <span class="comment"></span><span class="comment">//</span>
<a name="l00424"></a>00424 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00425"></a>00425 <span class="comment">//and written.</span>
<a name="l00426"></a>00426 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00427"></a>00427 <span class="comment">//returned.</span>
<a name="l00428"></a>00428 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00429"></a>00429 <span class="comment">//and written.</span>
<a name="l00430"></a>00430 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00431"></a>00431 <span class="comment">//returned.</span>
<a name="l00432"></a>00432 <span class="comment">//</span>
<a name="l00433"></a>00433 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00434"></a>00434 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00435"></a>00435 <span class="comment">//been called yet.</span>
<a name="l00436"></a>00436 <span class="comment">//</span>
<a name="l00437"></a>00437 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00438"></a>00438 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00439"></a>00439 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00440"></a>00440 <span class="comment">//*/</span>
<a name="l00441"></a>00441 <span class="comment">//  int LibStructural_getNDCMatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00442"></a>00442 <span class="comment">//                                                 char** *outColLabels, int *outColCount);</span>
<a name="l00444"></a>00444 <span class="comment"></span><span class="comment">//</span>
<a name="l00445"></a>00445 <span class="comment">//The N0 matrix is the set of linearly dependent rows of N where L0 Nr = N0.</span>
<a name="l00446"></a>00446 <span class="comment">//</span>
<a name="l00447"></a>00447 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00448"></a>00448 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00449"></a>00449 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00450"></a>00450 <span class="comment">//</span>
<a name="l00451"></a>00451 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00452"></a>00452 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00453"></a>00453 <span class="comment">//been called yet.</span>
<a name="l00454"></a>00454 <span class="comment">//</span>
<a name="l00455"></a>00455 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00456"></a>00456 <span class="comment">//and outRows as parameter.</span>
<a name="l00457"></a>00457 <span class="comment">//*/</span>
<a name="l00458"></a>00458 <span class="comment">//  int LibStructural_getN0Matrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00460"></a>00460 <span class="comment"></span><span class="comment">//</span>
<a name="l00461"></a>00461 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00462"></a>00462 <span class="comment">//and written.</span>
<a name="l00463"></a>00463 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00464"></a>00464 <span class="comment">//returned.</span>
<a name="l00465"></a>00465 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00466"></a>00466 <span class="comment">//and written.</span>
<a name="l00467"></a>00467 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00468"></a>00468 <span class="comment">//returned.</span>
<a name="l00469"></a>00469 <span class="comment">//</span>
<a name="l00470"></a>00470 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00471"></a>00471 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00472"></a>00472 <span class="comment">//been called yet.</span>
<a name="l00473"></a>00473 <span class="comment">//</span>
<a name="l00474"></a>00474 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00475"></a>00475 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00476"></a>00476 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00477"></a>00477 <span class="comment">//*/</span>
<a name="l00478"></a>00478 <span class="comment">//  int LibStructural_getN0MatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00479"></a>00479 <span class="comment">//                                                char** *outColLabels, int *outColCount);</span>
<a name="l00480"></a>00480 <span class="comment">//</span>
<a name="l00482"></a>00482 <span class="comment"></span><span class="comment">//</span>
<a name="l00483"></a>00483 <span class="comment">//L will have the structure, [I L0]&#39;, such that L Nr  = N</span>
<a name="l00484"></a>00484 <span class="comment">//</span>
<a name="l00485"></a>00485 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00486"></a>00486 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00487"></a>00487 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00488"></a>00488 <span class="comment">//</span>
<a name="l00489"></a>00489 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00490"></a>00490 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00491"></a>00491 <span class="comment">//been called yet.</span>
<a name="l00492"></a>00492 <span class="comment">//</span>
<a name="l00493"></a>00493 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00494"></a>00494 <span class="comment">//and outRows as parameter.</span>
<a name="l00495"></a>00495 <span class="comment">//*/</span>
<a name="l00496"></a>00496 <span class="comment">//  int LibStructural_getLinkMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00498"></a>00498 <span class="comment"></span><span class="comment">//</span>
<a name="l00499"></a>00499 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00500"></a>00500 <span class="comment">//and written.</span>
<a name="l00501"></a>00501 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00502"></a>00502 <span class="comment">//returned.</span>
<a name="l00503"></a>00503 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00504"></a>00504 <span class="comment">//and written.</span>
<a name="l00505"></a>00505 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00506"></a>00506 <span class="comment">//returned.</span>
<a name="l00507"></a>00507 <span class="comment">//</span>
<a name="l00508"></a>00508 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00509"></a>00509 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00510"></a>00510 <span class="comment">//been called yet.</span>
<a name="l00511"></a>00511 <span class="comment">//</span>
<a name="l00512"></a>00512 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00513"></a>00513 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00514"></a>00514 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00515"></a>00515 <span class="comment">//*/</span>
<a name="l00516"></a>00516 <span class="comment">//  int LibStructural_getLinkMatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00517"></a>00517 <span class="comment">//                                                  char** *outColLabels, int *outColCount);</span>
<a name="l00518"></a>00518 <span class="comment">//</span>
<a name="l00520"></a>00520 <span class="comment"></span><span class="comment">//</span>
<a name="l00521"></a>00521 <span class="comment">//K0 is defined such that K0 = -(NIC)^-1 NDC, or equivalently, [NDC NIC][I K0]&#39; = 0 where [NDC NIC] = Nr</span>
<a name="l00522"></a>00522 <span class="comment">//</span>
<a name="l00523"></a>00523 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00524"></a>00524 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00525"></a>00525 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00526"></a>00526 <span class="comment">//</span>
<a name="l00527"></a>00527 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00528"></a>00528 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00529"></a>00529 <span class="comment">//been called yet.</span>
<a name="l00530"></a>00530 <span class="comment">//</span>
<a name="l00531"></a>00531 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00532"></a>00532 <span class="comment">//and outRows as parameter.</span>
<a name="l00533"></a>00533 <span class="comment">//*/</span>
<a name="l00534"></a>00534 <span class="comment">//  int LibStructural_getK0Matrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00536"></a>00536 <span class="comment"></span><span class="comment">//</span>
<a name="l00537"></a>00537 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00538"></a>00538 <span class="comment">//and written.</span>
<a name="l00539"></a>00539 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00540"></a>00540 <span class="comment">//returned.</span>
<a name="l00541"></a>00541 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00542"></a>00542 <span class="comment">//and written.</span>
<a name="l00543"></a>00543 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00544"></a>00544 <span class="comment">//returned.</span>
<a name="l00545"></a>00545 <span class="comment">//</span>
<a name="l00546"></a>00546 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00547"></a>00547 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00548"></a>00548 <span class="comment">//been called yet.</span>
<a name="l00549"></a>00549 <span class="comment">//</span>
<a name="l00550"></a>00550 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00551"></a>00551 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00552"></a>00552 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00553"></a>00553 <span class="comment">//*/</span>
<a name="l00554"></a>00554 <span class="comment">//  int LibStructural_getK0MatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00555"></a>00555 <span class="comment">//                                                char** *outColLabels, int *outColCount);</span>
<a name="l00557"></a>00557 <span class="comment"></span><span class="comment">//The K matrix has the structure, [I K0]&#39;</span>
<a name="l00558"></a>00558 <span class="comment">//</span>
<a name="l00559"></a>00559 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00560"></a>00560 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00561"></a>00561 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00562"></a>00562 <span class="comment">//</span>
<a name="l00563"></a>00563 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00564"></a>00564 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00565"></a>00565 <span class="comment">//been called yet.</span>
<a name="l00566"></a>00566 <span class="comment">//</span>
<a name="l00567"></a>00567 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00568"></a>00568 <span class="comment">//and outRows as parameter.</span>
<a name="l00569"></a>00569 <span class="comment">//*/</span>
<a name="l00570"></a>00570 <span class="comment">//  int LibStructural_getKMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00572"></a>00572 <span class="comment"></span><span class="comment">//</span>
<a name="l00573"></a>00573 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00574"></a>00574 <span class="comment">//and written.</span>
<a name="l00575"></a>00575 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00576"></a>00576 <span class="comment">//returned.</span>
<a name="l00577"></a>00577 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00578"></a>00578 <span class="comment">//and written.</span>
<a name="l00579"></a>00579 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00580"></a>00580 <span class="comment">//returned.</span>
<a name="l00581"></a>00581 <span class="comment">//</span>
<a name="l00582"></a>00582 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00583"></a>00583 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00584"></a>00584 <span class="comment">//been called yet.</span>
<a name="l00585"></a>00585 <span class="comment">//</span>
<a name="l00586"></a>00586 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00587"></a>00587 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00588"></a>00588 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00589"></a>00589 <span class="comment">//*/</span>
<a name="l00590"></a>00590 <span class="comment">//  int LibStructural_getKMatrixLabels(char** *outRowLabels, int *outRowCount,</span>
<a name="l00591"></a>00591 <span class="comment">//                                               char** *outColLabels, int *outColCount);</span>
<a name="l00592"></a>00592 <span class="comment">//</span>
<a name="l00594"></a>00594 <span class="comment"></span><span class="comment">//</span>
<a name="l00595"></a>00595 <span class="comment">//Each row represents a single conservation law where the column indicate the</span>
<a name="l00596"></a>00596 <span class="comment">//participating molecular species. The number of rows is therefore equal to the</span>
<a name="l00597"></a>00597 <span class="comment">//number of conservation laws. Columns are ordered according to the rows in the</span>
<a name="l00598"></a>00598 <span class="comment">//reordered stoichiometry matrix, see ::LibStructural_getReorderedSpeciesId and</span>
<a name="l00599"></a>00599 <span class="comment">//::LibStructural_getReorderedStoichiometryMatrix.</span>
<a name="l00600"></a>00600 <span class="comment">//</span>
<a name="l00601"></a>00601 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00602"></a>00602 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00603"></a>00603 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00604"></a>00604 <span class="comment">//</span>
<a name="l00605"></a>00605 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00606"></a>00606 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00607"></a>00607 <span class="comment">//been called yet.</span>
<a name="l00608"></a>00608 <span class="comment">//</span>
<a name="l00609"></a>00609 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00610"></a>00610 <span class="comment">//and outRows as parameter.</span>
<a name="l00611"></a>00611 <span class="comment">//*/</span>
<a name="l00612"></a>00612 <span class="comment">// int LibStructural_getGammaMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00613"></a>00613 <span class="comment">//</span>
<a name="l00614"></a>00614 <span class="comment">// int LibStructural_getGammaMatrixGJ(double** inMatrix, int numRows, int numCols,</span>
<a name="l00615"></a>00615 <span class="comment">//                                          double** *outMatrix, int *outRows, int *outCols);</span>
<a name="l00616"></a>00616 <span class="comment">//</span>
<a name="l00617"></a>00617 <span class="comment">// int LibStructural_findPositiveGammaMatrix(double** inMatrix, int numRows, int numCols,</span>
<a name="l00618"></a>00618 <span class="comment">//                const char** inRowLabels,</span>
<a name="l00619"></a>00619 <span class="comment">//                double** *outMatrix, int *outRows, int *outCols,</span>
<a name="l00620"></a>00620 <span class="comment">//                char** *outRowLabels, int *outRowCount);</span>
<a name="l00621"></a>00621 <span class="comment">//</span>
<a name="l00622"></a>00622 <span class="comment">//</span>
<a name="l00624"></a>00624 <span class="comment"></span><span class="comment">//</span>
<a name="l00625"></a>00625 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00626"></a>00626 <span class="comment">//and written.</span>
<a name="l00627"></a>00627 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00628"></a>00628 <span class="comment">//returned.</span>
<a name="l00629"></a>00629 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00630"></a>00630 <span class="comment">//and written.</span>
<a name="l00631"></a>00631 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00632"></a>00632 <span class="comment">//returned.</span>
<a name="l00633"></a>00633 <span class="comment">//</span>
<a name="l00634"></a>00634 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00635"></a>00635 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00636"></a>00636 <span class="comment">//been called yet.</span>
<a name="l00637"></a>00637 <span class="comment">//</span>
<a name="l00638"></a>00638 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00639"></a>00639 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00640"></a>00640 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00641"></a>00641 <span class="comment">//*/</span>
<a name="l00642"></a>00642 <span class="comment">//  int LibStructural_getGammaMatrixLabels(char** *outRowLabels, int *outRowCount, char** *outColLabels, int *outColCount);</span>
<a name="l00644"></a>00644 <span class="comment"></span><span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00645"></a>00645 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00646"></a>00646 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00647"></a>00647 <span class="comment">//</span>
<a name="l00648"></a>00648 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00649"></a>00649 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00650"></a>00650 <span class="comment">//been called yet.</span>
<a name="l00651"></a>00651 <span class="comment">//</span>
<a name="l00652"></a>00652 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00653"></a>00653 <span class="comment">//and outRows as parameter.</span>
<a name="l00654"></a>00654 <span class="comment">//*/</span>
<a name="l00655"></a>00655 <span class="comment">//  int LibStructural_getStoichiometryMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00657"></a>00657 <span class="comment"></span><span class="comment">//</span>
<a name="l00658"></a>00658 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00659"></a>00659 <span class="comment">//and written.</span>
<a name="l00660"></a>00660 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00661"></a>00661 <span class="comment">//returned.</span>
<a name="l00662"></a>00662 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00663"></a>00663 <span class="comment">//and written.</span>
<a name="l00664"></a>00664 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00665"></a>00665 <span class="comment">//returned.</span>
<a name="l00666"></a>00666 <span class="comment">//</span>
<a name="l00667"></a>00667 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00668"></a>00668 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00669"></a>00669 <span class="comment">//been called yet.</span>
<a name="l00670"></a>00670 <span class="comment">//</span>
<a name="l00671"></a>00671 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00672"></a>00672 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00673"></a>00673 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00674"></a>00674 <span class="comment">//*/</span>
<a name="l00675"></a>00675 <span class="comment">//  int LibStructural_getStoichiometryMatrixLabels(char** *outRowLabels, int *outRowCount, char** *outColLabels, int *outColCount);</span>
<a name="l00677"></a>00677 <span class="comment"></span><span class="comment">//</span>
<a name="l00678"></a>00678 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00679"></a>00679 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00680"></a>00680 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00681"></a>00681 <span class="comment">//</span>
<a name="l00682"></a>00682 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00683"></a>00683 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00684"></a>00684 <span class="comment">//been called yet.</span>
<a name="l00685"></a>00685 <span class="comment">//</span>
<a name="l00686"></a>00686 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00687"></a>00687 <span class="comment">//and outRows as parameter.</span>
<a name="l00688"></a>00688 <span class="comment">//*/</span>
<a name="l00689"></a>00689 <span class="comment">//  int LibStructural_getFullyReorderedStoichiometryMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00691"></a>00691 <span class="comment"></span><span class="comment">//</span>
<a name="l00692"></a>00692 <span class="comment">//\param outMatrix a pointer to a double array that holds the output</span>
<a name="l00693"></a>00693 <span class="comment">//\param outRows will be overwritten with the number of rows</span>
<a name="l00694"></a>00694 <span class="comment">//\param outCols will be overwritten with the number of columns.</span>
<a name="l00695"></a>00695 <span class="comment">//</span>
<a name="l00696"></a>00696 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00697"></a>00697 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00698"></a>00698 <span class="comment">//been called yet.</span>
<a name="l00699"></a>00699 <span class="comment">//</span>
<a name="l00700"></a>00700 <span class="comment">//\remarks To free the returned matrix call ::LibStructural_freeMatrix with the outMatrix</span>
<a name="l00701"></a>00701 <span class="comment">//and outRows as parameter.</span>
<a name="l00702"></a>00702 <span class="comment">//*/</span>
<a name="l00703"></a>00703 <span class="comment">//  int LibStructural_getReorderedStoichiometryMatrix(double** *outMatrix, int* outRows, int *outCols);</span>
<a name="l00705"></a>00705 <span class="comment"></span><span class="comment">//</span>
<a name="l00706"></a>00706 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00707"></a>00707 <span class="comment">//and written.</span>
<a name="l00708"></a>00708 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00709"></a>00709 <span class="comment">//returned.</span>
<a name="l00710"></a>00710 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00711"></a>00711 <span class="comment">//and written.</span>
<a name="l00712"></a>00712 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00713"></a>00713 <span class="comment">//returned.</span>
<a name="l00714"></a>00714 <span class="comment">//</span>
<a name="l00715"></a>00715 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00716"></a>00716 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00717"></a>00717 <span class="comment">//been called yet.</span>
<a name="l00718"></a>00718 <span class="comment">//</span>
<a name="l00719"></a>00719 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00720"></a>00720 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00721"></a>00721 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00722"></a>00722 <span class="comment">//*/</span>
<a name="l00723"></a>00723 <span class="comment">//  int LibStructural_getFullyReorderedStoichiometryMatrixLabels(char** *outRowLabels, int *outRowCount, char** *outColLabels, int *outColCount);</span>
<a name="l00724"></a>00724 <span class="comment">//</span>
<a name="l00726"></a>00726 <span class="comment"></span><span class="comment">//</span>
<a name="l00727"></a>00727 <span class="comment">//\param outRowLabels a pointer to a string array where the row labels will be allocated</span>
<a name="l00728"></a>00728 <span class="comment">//and written.</span>
<a name="l00729"></a>00729 <span class="comment">//\param outRowCount after the call this variable will hold the number of row labels</span>
<a name="l00730"></a>00730 <span class="comment">//returned.</span>
<a name="l00731"></a>00731 <span class="comment">//\param outColLabels a pointer to a string array where the column labels will be allocated</span>
<a name="l00732"></a>00732 <span class="comment">//and written.</span>
<a name="l00733"></a>00733 <span class="comment">//\param outColCount after the call this variable will hold the number of column labels</span>
<a name="l00734"></a>00734 <span class="comment">//returned.</span>
<a name="l00735"></a>00735 <span class="comment">//</span>
<a name="l00736"></a>00736 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00737"></a>00737 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00738"></a>00738 <span class="comment">//been called yet.</span>
<a name="l00739"></a>00739 <span class="comment">//</span>
<a name="l00740"></a>00740 <span class="comment">//\remarks To free the string arrays (outRowLabels and outColLabels) call</span>
<a name="l00741"></a>00741 <span class="comment">//::LibStructural_freeMatrix with the string array and its corresponding length</span>
<a name="l00742"></a>00742 <span class="comment">//(outRowCount or outColCount)</span>
<a name="l00743"></a>00743 <span class="comment">//*/</span>
<a name="l00744"></a>00744 <span class="comment">//  int LibStructural_getReorderedStoichiometryMatrixLabels(char** *outRowLabels, int *outRowCount, char** *outColLabels, int *outColCount);</span>
<a name="l00745"></a>00745 <span class="comment">//</span>
<a name="l00747"></a>00747 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled with the species Ids</span>
<a name="l00748"></a>00748 <span class="comment">//\param outLength the number of species</span>
<a name="l00749"></a>00749 <span class="comment">//</span>
<a name="l00750"></a>00750 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00751"></a>00751 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00752"></a>00752 <span class="comment">//been called yet.</span>
<a name="l00753"></a>00753 <span class="comment">//</span>
<a name="l00754"></a>00754 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00755"></a>00755 <span class="comment">//*/</span>
<a name="l00756"></a>00756 <span class="comment">//  int LibStructural_getReorderedSpeciesIds(char** *outArray, int *outLength);</span>
<a name="l00757"></a>00757 <span class="comment">//</span>
<a name="l00758"></a>00758 <span class="comment">//</span>
<a name="l00760"></a>00760 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled with the species Ids</span>
<a name="l00761"></a>00761 <span class="comment">//\param outLength the number of species</span>
<a name="l00762"></a>00762 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00763"></a>00763 <span class="comment">//</span>
<a name="l00764"></a>00764 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00765"></a>00765 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00766"></a>00766 <span class="comment">//been called yet.</span>
<a name="l00767"></a>00767 <span class="comment">//</span>
<a name="l00768"></a>00768 <span class="comment">//*/</span>
<a name="l00769"></a>00769 <span class="comment">//  int LibStructural_getSpeciesIds(char** *outArray, int *outLength);</span>
<a name="l00770"></a>00770 <span class="comment">//</span>
<a name="l00772"></a>00772 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled with the reordered reaction Ids</span>
<a name="l00773"></a>00773 <span class="comment">//\param outLength the number of species</span>
<a name="l00774"></a>00774 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00775"></a>00775 <span class="comment">//</span>
<a name="l00776"></a>00776 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00777"></a>00777 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00778"></a>00778 <span class="comment">//been called yet.</span>
<a name="l00779"></a>00779 <span class="comment">//</span>
<a name="l00780"></a>00780 <span class="comment">//*/</span>
<a name="l00781"></a>00781 <span class="comment">//  int LibStructural_getReorderedReactionIds(char** *outArray, int *outLength);</span>
<a name="l00782"></a>00782 <span class="comment">//</span>
<a name="l00784"></a>00784 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled with the independent species Ids</span>
<a name="l00785"></a>00785 <span class="comment">//\param outLength the number of independent species</span>
<a name="l00786"></a>00786 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00787"></a>00787 <span class="comment">//</span>
<a name="l00788"></a>00788 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00789"></a>00789 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00790"></a>00790 <span class="comment">//been called yet.</span>
<a name="l00791"></a>00791 <span class="comment">//</span>
<a name="l00792"></a>00792 <span class="comment">//*/</span>
<a name="l00793"></a>00793 <span class="comment">//  int LibStructural_getIndependentSpeciesIds(char** *outArray, int *outLength);</span>
<a name="l00794"></a>00794 <span class="comment">//</span>
<a name="l00796"></a>00796 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled with the dependent species Ids</span>
<a name="l00797"></a>00797 <span class="comment">//\param outLength the number of dependent species</span>
<a name="l00798"></a>00798 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00799"></a>00799 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00800"></a>00800 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00801"></a>00801 <span class="comment">//been called yet.</span>
<a name="l00802"></a>00802 <span class="comment">//</span>
<a name="l00803"></a>00803 <span class="comment">//</span>
<a name="l00804"></a>00804 <span class="comment">//*/</span>
<a name="l00805"></a>00805 <span class="comment">//  int LibStructural_getDependentSpeciesIds(char** *outArray, int *outLength);</span>
<a name="l00806"></a>00806 <span class="comment">//</span>
<a name="l00808"></a>00808 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled with the independent reaction Ids</span>
<a name="l00809"></a>00809 <span class="comment">//\param outLength the number of independent reaction</span>
<a name="l00810"></a>00810 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00811"></a>00811 <span class="comment">//</span>
<a name="l00812"></a>00812 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00813"></a>00813 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00814"></a>00814 <span class="comment">//been called yet.</span>
<a name="l00815"></a>00815 <span class="comment">//</span>
<a name="l00816"></a>00816 <span class="comment">//*/</span>
<a name="l00817"></a>00817 <span class="comment">//  int LibStructural_getIndependentReactionIds(char** *outArray, int *outLength);</span>
<a name="l00818"></a>00818 <span class="comment">//</span>
<a name="l00820"></a>00820 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled with the dependent reaction Ids</span>
<a name="l00821"></a>00821 <span class="comment">//\param outLength the number of dependent reactions</span>
<a name="l00822"></a>00822 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00823"></a>00823 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00824"></a>00824 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00825"></a>00825 <span class="comment">//been called yet.</span>
<a name="l00826"></a>00826 <span class="comment">//</span>
<a name="l00827"></a>00827 <span class="comment">//</span>
<a name="l00828"></a>00828 <span class="comment">//*/</span>
<a name="l00829"></a>00829 <span class="comment">//  int LibStructural_getDependentReactionIds(char** *outArray, int *outLength);</span>
<a name="l00830"></a>00830 <span class="comment">//</span>
<a name="l00832"></a>00832 <span class="comment"></span><span class="comment">//Returns the original list of reactions in the same order as when it was loaded.</span>
<a name="l00833"></a>00833 <span class="comment">//\param outArray pointer to string array that will be allocated and filled with the reaction Ids</span>
<a name="l00834"></a>00834 <span class="comment">//\param outLength the number of reactions</span>
<a name="l00835"></a>00835 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00836"></a>00836 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00837"></a>00837 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00838"></a>00838 <span class="comment">//been called yet.</span>
<a name="l00839"></a>00839 <span class="comment">//</span>
<a name="l00840"></a>00840 <span class="comment">//*/</span>
<a name="l00841"></a>00841 <span class="comment">//  int LibStructural_getReactionIds(char** *outArray, int *outLength);</span>
<a name="l00842"></a>00842 <span class="comment">//</span>
<a name="l00844"></a>00844 <span class="comment"></span><span class="comment">//\param outArray pointer to string array that will be allocated and filled</span>
<a name="l00845"></a>00845 <span class="comment">//\param outLength the number of conservation laws</span>
<a name="l00846"></a>00846 <span class="comment">//\remarks free outArray using ::LibStructural_freeMatrix with the outLength parameter</span>
<a name="l00847"></a>00847 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00848"></a>00848 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00849"></a>00849 <span class="comment">//been called yet.</span>
<a name="l00850"></a>00850 <span class="comment">//</span>
<a name="l00851"></a>00851 <span class="comment">//*/</span>
<a name="l00852"></a>00852 <span class="comment">//  int LibStructural_getConservedLaws(char** *outArray, int *outLength);</span>
<a name="l00853"></a>00853 <span class="comment">//</span>
<a name="l00855"></a>00855 <span class="comment"></span><span class="comment">//\return the number of conservation laws</span>
<a name="l00856"></a>00856 <span class="comment">//*/</span>
<a name="l00857"></a>00857 <span class="comment">//  int LibStructural_getNumConservedSums();</span>
<a name="l00859"></a>00859 <span class="comment"></span><span class="comment">//</span>
<a name="l00860"></a>00860 <span class="comment">//\param outArray will be allocated and filled with a double vector of all conserved sums</span>
<a name="l00861"></a>00861 <span class="comment">//\param outLength is the number of conserved sums</span>
<a name="l00862"></a>00862 <span class="comment">//\remarks free outArray using ::LibStructural_freeVector</span>
<a name="l00863"></a>00863 <span class="comment">//</span>
<a name="l00864"></a>00864 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00865"></a>00865 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00866"></a>00866 <span class="comment">//been called yet.</span>
<a name="l00867"></a>00867 <span class="comment">//</span>
<a name="l00868"></a>00868 <span class="comment">//*/</span>
<a name="l00869"></a>00869 <span class="comment">// int LibStructural_getConservedSums(double* *outArray, int *outLength);</span>
<a name="l00870"></a>00870 <span class="comment">//</span>
<a name="l00872"></a>00872 <span class="comment"></span><span class="comment">//\param outVariableNames a string vector of all species Ids</span>
<a name="l00873"></a>00873 <span class="comment">//\param outValues a double vector of corresponding initial conditions</span>
<a name="l00874"></a>00874 <span class="comment">//\param outLength number of elements in outVariableNames and outValues (number of species)</span>
<a name="l00875"></a>00875 <span class="comment">//*/</span>
<a name="l00876"></a>00876 <span class="comment">//  int LibStructural_getInitialConditions(char** *outVariableNames, double* *outValues, int *outLength);</span>
<a name="l00877"></a>00877 <span class="comment">//</span>
<a name="l00879"></a>00879 <span class="comment"></span><span class="comment">//</span>
<a name="l00880"></a>00880 <span class="comment">//Calling this method will run the internal test suite against the structural</span>
<a name="l00881"></a>00881 <span class="comment">//matrices those tests include:\n</span>
<a name="l00882"></a>00882 <span class="comment">//</span>
<a name="l00883"></a>00883 <span class="comment">//\li Test 1 : Gamma*N = 0 (Zero matrix)</span>
<a name="l00884"></a>00884 <span class="comment">//\li Test 2 : Rank(N) using SVD (5) is same as m0 (5)</span>
<a name="l00885"></a>00885 <span class="comment">//\li Test 3 : Rank(NR) using SVD (5) is same as m0 (5)</span>
<a name="l00886"></a>00886 <span class="comment">//\li Test 4 : Rank(NR) using QR (5) is same as m0 (5)</span>
<a name="l00887"></a>00887 <span class="comment">//\li Test 5 : L0 obtained with QR matches Q21*inv(Q11)</span>
<a name="l00888"></a>00888 <span class="comment">//\li Test 6 : N*K = 0 (Zero matrix)</span>
<a name="l00889"></a>00889 <span class="comment">//</span>
<a name="l00890"></a>00890 <span class="comment">//\param outResults an integer vector, each element represents the result for one</span>
<a name="l00891"></a>00891 <span class="comment">//of the above tests (the 0th element representing the test result for test1),</span>
<a name="l00892"></a>00892 <span class="comment">//if the test passed the value is 1 and 0 otherwise.</span>
<a name="l00893"></a>00893 <span class="comment">//\param outLength number of tests</span>
<a name="l00894"></a>00894 <span class="comment">//</span>
<a name="l00895"></a>00895 <span class="comment">//\remarks free outResults using ::LibStructural_freeVector</span>
<a name="l00896"></a>00896 <span class="comment">//</span>
<a name="l00897"></a>00897 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00898"></a>00898 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00899"></a>00899 <span class="comment">//been called yet.</span>
<a name="l00900"></a>00900 <span class="comment">//</span>
<a name="l00901"></a>00901 <span class="comment">//*/</span>
<a name="l00902"></a>00902 <span class="comment">//  int  LibStructural_validateStructuralMatrices(int* *outResults, int* outLength);</span>
<a name="l00904"></a>00904 <span class="comment"></span><span class="comment">//\param outMessage a pointer to a string where status information of the analysis</span>
<a name="l00905"></a>00905 <span class="comment">//will be returned.</span>
<a name="l00906"></a>00906 <span class="comment">//\param nLength the length of the message.</span>
<a name="l00907"></a>00907 <span class="comment">//\remarks free outMessage using ::LibStructural_freeVector</span>
<a name="l00908"></a>00908 <span class="comment">//</span>
<a name="l00909"></a>00909 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00910"></a>00910 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00911"></a>00911 <span class="comment">//been called yet.</span>
<a name="l00912"></a>00912 <span class="comment">//</span>
<a name="l00913"></a>00913 <span class="comment">//*/</span>
<a name="l00914"></a>00914 <span class="comment">//  int LibStructural_getTestDetails(char* *outMessage, int *nLength);</span>
<a name="l00915"></a>00915 <span class="comment">//</span>
<a name="l00917"></a>00917 <span class="comment"></span><span class="comment">//</span>
<a name="l00918"></a>00918 <span class="comment">//Returns the name of the model if SBML model has Name-tag, otherwise it returns the</span>
<a name="l00919"></a>00919 <span class="comment">//SBML id. If only a stoichiometry matrix was loaded &#39;untitled&#39; will be returned.</span>
<a name="l00920"></a>00920 <span class="comment">//</span>
<a name="l00921"></a>00921 <span class="comment">//\param outMessage a pointer to a string where status information of the analysis</span>
<a name="l00922"></a>00922 <span class="comment">//will be returned.</span>
<a name="l00923"></a>00923 <span class="comment">//\param nLength the length of the message.</span>
<a name="l00924"></a>00924 <span class="comment">//\remarks free outMessage using ::LibStructural_freeVector</span>
<a name="l00925"></a>00925 <span class="comment">//</span>
<a name="l00926"></a>00926 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l00927"></a>00927 <span class="comment">//no stoichiometry matrix was loaded beforehand or none of the analysis methods has</span>
<a name="l00928"></a>00928 <span class="comment">//been called yet.</span>
<a name="l00929"></a>00929 <span class="comment">//</span>
<a name="l00930"></a>00930 <span class="comment">//*/</span>
<a name="l00931"></a>00931 <span class="comment">//  int LibStructural_getModelName(char* *outMessage, int *nLength);</span>
<a name="l00932"></a>00932 <span class="comment">//</span>
<a name="l00934"></a>00934 <span class="comment"></span><span class="comment">//  int LibStructural_getNumSpecies();</span>
<a name="l00935"></a>00935 <span class="comment">//</span>
<a name="l00937"></a>00937 <span class="comment"></span><span class="comment">//  int LibStructural_getNumIndSpecies();</span>
<a name="l00938"></a>00938 <span class="comment">//</span>
<a name="l00940"></a>00940 <span class="comment"></span><span class="comment">//  int LibStructural_getNumDepSpecies();</span>
<a name="l00942"></a>00942 <span class="comment"></span><span class="comment">//  int LibStructural_getNumReactions();</span>
<a name="l00944"></a>00944 <span class="comment"></span><span class="comment">//  int LibStructural_getNumIndReactions();</span>
<a name="l00946"></a>00946 <span class="comment"></span><span class="comment">//  int LibStructural_getNumDepReactions();</span>
<a name="l00948"></a>00948 <span class="comment"></span><span class="comment">//  int LibStructural_getRank();</span>
<a name="l00950"></a>00950 <span class="comment"></span><span class="comment">//  double LibStructural_getNmatrixSparsity();</span>
<a name="l00951"></a>00951 <span class="comment">//</span>
<a name="l00953"></a>00953 <span class="comment"></span><span class="comment">//</span>
<a name="l00954"></a>00954 <span class="comment">//This function sets the tolerance used by the library to determine what value</span>
<a name="l00955"></a>00955 <span class="comment">//is considered as zero. Any value with absolute value smaller than this tolerance is considered as zero</span>
<a name="l00956"></a>00956 <span class="comment">//and will be neglected.</span>
<a name="l00957"></a>00957 <span class="comment">//</span>
<a name="l00958"></a>00958 <span class="comment">//\param dTolerance Sets the tolerance used by the library to determine a  value close to zero</span>
<a name="l00959"></a>00959 <span class="comment">//*/</span>
<a name="l00960"></a>00960 <span class="comment">//  void LibStructural_setTolerance(const double dTolerance);</span>
<a name="l00961"></a>00961 <span class="comment">//</span>
<a name="l00963"></a>00963 <span class="comment"></span><span class="comment">//</span>
<a name="l00964"></a>00964 <span class="comment">//This function gets the tolerance used by the library to determine what value</span>
<a name="l00965"></a>00965 <span class="comment">//is considered as zero. Any value with absolute value smaller than this tolerance is considered as zero</span>
<a name="l00966"></a>00966 <span class="comment">//and will be neglected.</span>
<a name="l00967"></a>00967 <span class="comment">//</span>
<a name="l00968"></a>00968 <span class="comment">//\return the tolerance used by the library to determine a  value close to zero</span>
<a name="l00969"></a>00969 <span class="comment">//*/</span>
<a name="l00970"></a>00970 <span class="comment">//  double LibStructural_getTolerance();</span>
<a name="l00971"></a>00971 <span class="comment">//</span>
<a name="l00972"></a>00972 <span class="comment">//</span>
<a name="l00974"></a>00974 <span class="comment"></span><span class="comment">// void LibStructural_freeVector(void* vector);</span>
<a name="l00975"></a>00975 <span class="comment">//</span>
<a name="l00977"></a>00977 <span class="comment"></span><span class="comment">// void LibStructural_freeMatrix(void** matrix, int numRows);</span>
<a name="l00978"></a>00978 <span class="comment">//</span>
<a name="l00985"></a>00985 <span class="comment"></span><span class="comment">//</span>
<a name="l00986"></a>00986 <span class="comment">//} //namespace ..</span>
<a name="l00987"></a>00987 <span class="comment">//END_C_DECLS;</span>
<a name="l00988"></a>00988 <span class="comment">//#endif</span>
<a name="l00989"></a>00989 <span class="comment">//</span>
<a name="l00990"></a>00990 <span class="comment">//#endif</span>
<a name="l00991"></a>00991 <span class="comment">//</span>
<a name="l00992"></a>00992 <span class="comment">//</span>
<a name="l00994"></a>00994 <span class="comment"></span><span class="comment">//</span>
<a name="l00995"></a>00995 <span class="comment">//\par</span>
<a name="l00996"></a>00996 <span class="comment">//This document describes the application programming interface (API) of LibLA and LibStructural  an open source (BSD) library for computing structural characteristics of cellular networks.</span>
<a name="l00997"></a>00997 <span class="comment">//\par</span>
<a name="l00998"></a>00998 <span class="comment">//LibLA is a linear algebra library derives much of its functionality from the standard CLAPACK library with additional linear algebra functions not directly supported by CLAPACK. The libStructural library supports a range of methods for the structural analysis of cellular networks (derived either from SBML or stoichiometry matrices) and utilizes LibLA for some of its internal computations.</span>
<a name="l00999"></a>00999 <span class="comment">//\par Installing</span>
<a name="l01000"></a>01000 <span class="comment">//To make the Structural Analysis Library easily accessible we have created binary installers for Windows as wel as OS X (version 10.4 and above).</span>
<a name="l01001"></a>01001 <span class="comment">//We also habe a source distribution, complete with Visual Studio, XCode, Scons and Qt project files that allow to build the library on Windows, Linux and OS X. For detailed instructions on how to build the library see the file INSTALL included with the source distribution.</span>
<a name="l01002"></a>01002 <span class="comment">//\par Dependencies</span>
<a name="l01003"></a>01003 <span class="comment">//These libraries depend on two third-party libraries, LAPACK and libSBML.  Both are provided with the binary installation where necessary.</span>
<a name="l01004"></a>01004 <span class="comment">//\par</span>
<a name="l01005"></a>01005 <span class="comment">//This work was supported by a grant from the NIH (1R01GM0819070-01).</span>
<a name="l01006"></a>01006 <span class="comment">//</span>
<a name="l01007"></a>01007 <span class="comment">//</span>
<a name="l01008"></a>01008 <span class="comment">//\author  Frank T. Bergmann (fbergman@u.washington.edu)</span>
<a name="l01009"></a>01009 <span class="comment">//\author     Herbert M. Sauro</span>
<a name="l01010"></a>01010 <span class="comment">//\author     Ravishankar Rao Vallabhajosyula (developed a previous version of the sructural analysis code)</span>
<a name="l01011"></a>01011 <span class="comment">//</span>
<a name="l01012"></a>01012 <span class="comment">//\par License</span>
<a name="l01013"></a>01013 <span class="comment">//\par</span>
<a name="l01014"></a>01014 <span class="comment">//Copyright (c) 2008, Frank T Bergmann and Herbert M Sauro\n</span>
<a name="l01015"></a>01015 <span class="comment">//All rights reserved.</span>
<a name="l01016"></a>01016 <span class="comment">//</span>
<a name="l01017"></a>01017 <span class="comment">//\par</span>
<a name="l01018"></a>01018 <span class="comment">//Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l01019"></a>01019 <span class="comment">//</span>
<a name="l01020"></a>01020 <span class="comment">//\li Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l01021"></a>01021 <span class="comment">//</span>
<a name="l01022"></a>01022 <span class="comment">//\li Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l01023"></a>01023 <span class="comment">//</span>
<a name="l01024"></a>01024 <span class="comment">//\li Neither the name of University of Washington nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</span>
<a name="l01025"></a>01025 <span class="comment">//</span>
<a name="l01026"></a>01026 <span class="comment">//\par</span>
<a name="l01027"></a>01027 <span class="comment">//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l01028"></a>01028 <span class="comment">//</span>
<a name="l01029"></a>01029 <span class="comment">//</span>
<a name="l01030"></a>01030 <span class="comment">//*/</span>
<a name="l01032"></a>01032 <span class="comment"></span><span class="comment">//</span>
<a name="l01059"></a>01059 <span class="comment"></span><span class="comment">//</span>
<a name="l01060"></a>01060 <span class="comment">//</span>
<a name="l01061"></a>01061 <span class="comment">//</span>
<a name="l01062"></a>01062 <span class="comment">//</span>
<a name="l01064"></a>01064 <span class="comment"></span><span class="comment">//BEGIN_C_DECLS;</span>
<a name="l01066"></a>01066 <span class="comment"></span><span class="comment">//</span>
<a name="l01067"></a>01067 <span class="comment">//This function returns the tolerance currently used by the library to determine what value</span>
<a name="l01068"></a>01068 <span class="comment">//is considered as zero. Any value with absolute value smaller than this tolerance is considered zero</span>
<a name="l01069"></a>01069 <span class="comment">//and will be neglected.</span>
<a name="l01070"></a>01070 <span class="comment">//*/</span>
<a name="l01071"></a>01071 <span class="comment">//LIB_EXTERN double LibLA_getTolerance();</span>
<a name="l01072"></a>01072 <span class="comment">//</span>
<a name="l01074"></a>01074 <span class="comment"></span><span class="comment">//</span>
<a name="l01075"></a>01075 <span class="comment">//This function sets the tolerance used by the library to determine what value</span>
<a name="l01076"></a>01076 <span class="comment">//is considered as zero. Any value with absolute value smaller than this tolerance is considered as zero</span>
<a name="l01077"></a>01077 <span class="comment">//and will be neglected.</span>
<a name="l01078"></a>01078 <span class="comment">//</span>
<a name="l01079"></a>01079 <span class="comment">//\param value Sets the tolerance used by the library to determine a  value close to zero</span>
<a name="l01080"></a>01080 <span class="comment">//*/</span>
<a name="l01081"></a>01081 <span class="comment">//LIB_EXTERN void LibLA_setTolerance(const double value);</span>
<a name="l01082"></a>01082 <span class="comment">//</span>
<a name="l01084"></a>01084 <span class="comment"></span><span class="comment">//</span>
<a name="l01085"></a>01085 <span class="comment">//This function calculates the complex eigenvalues of the given real matrix. The complex vector</span>
<a name="l01086"></a>01086 <span class="comment">//of eigenvalues will be returned in two real vectors, one for the real and one for the imaginary part.</span>
<a name="l01087"></a>01087 <span class="comment">//</span>
<a name="l01088"></a>01088 <span class="comment">//\param inMatrix real matrix to calculate the eigen-values for.</span>
<a name="l01089"></a>01089 <span class="comment">//\param numRows the number of rows of the input matrix</span>
<a name="l01090"></a>01090 <span class="comment">//\param numCols the number of columns of the input matrix</span>
<a name="l01091"></a>01091 <span class="comment">//\param outReal pointer to the output array for the eigenvalues (real part)</span>
<a name="l01092"></a>01092 <span class="comment">//\param outImag pointer to the output array for the eigenvalues (imaginary part)</span>
<a name="l01093"></a>01093 <span class="comment">//\param outLength the number of eigenvalues written to outReal and outImag</span>
<a name="l01094"></a>01094 <span class="comment">//</span>
<a name="l01095"></a>01095 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l01096"></a>01096 <span class="comment">//an error occurred (for example because the caller supplied a non-square matrix)</span>
<a name="l01097"></a>01097 <span class="comment">//</span>
<a name="l01098"></a>01098 <span class="comment">//\remarks free outReal and outImag using ::LibLA_freeVector</span>
<a name="l01099"></a>01099 <span class="comment">//</span>
<a name="l01100"></a>01100 <span class="comment">//*/</span>
<a name="l01101"></a>01101 <span class="comment">//LIB_EXTERN int LibLA_getEigenValues(double** inMatrix, int numRows, int numCols, double* *outReal, double * *outImag, int *outLength);</span>
<a name="l01102"></a>01102 <span class="comment">//</span>
<a name="l01104"></a>01104 <span class="comment"></span><span class="comment">//</span>
<a name="l01105"></a>01105 <span class="comment">//This function calculates the complex eigenvalues of the given complex matrix. The input matrix</span>
<a name="l01106"></a>01106 <span class="comment">//should be broken up into two matrices representing the real and imaginary parts respectively.</span>
<a name="l01107"></a>01107 <span class="comment">//The complex vector of eigenvalues will be returned in two  real vectors, one for the real and</span>
<a name="l01108"></a>01108 <span class="comment">//one for the imaginary part.</span>
<a name="l01109"></a>01109 <span class="comment">//</span>
<a name="l01110"></a>01110 <span class="comment">//\param inMatrixReal real part of the complex matrix to calculate the eigen-values for.</span>
<a name="l01111"></a>01111 <span class="comment">//\param inMatrixImag imaginary part of the complex matrix to calculate the eigen-values for</span>
<a name="l01112"></a>01112 <span class="comment">//\param numRows the number of rows of the input matrix</span>
<a name="l01113"></a>01113 <span class="comment">//\param numCols the number of columns of the input matrix</span>
<a name="l01114"></a>01114 <span class="comment">//\param outReal pointer to the output array for the eigenvalues (real part)</span>
<a name="l01115"></a>01115 <span class="comment">//\param outImag pointer to the output array for the eigenvalues (imaginary part)</span>
<a name="l01116"></a>01116 <span class="comment">//\param outLength the number of eigenvalues written to outReal and outImag</span>
<a name="l01117"></a>01117 <span class="comment">//</span>
<a name="l01118"></a>01118 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l01119"></a>01119 <span class="comment">//an error occurred (for example non square matrix)</span>
<a name="l01120"></a>01120 <span class="comment">//</span>
<a name="l01121"></a>01121 <span class="comment">//\remarks free outReal and outImag using ::LibLA_freeVector</span>
<a name="l01122"></a>01122 <span class="comment">//</span>
<a name="l01123"></a>01123 <span class="comment">//*/</span>
<a name="l01124"></a>01124 <span class="comment">//LIB_EXTERN int LibLA_ZgetEigenValues(double** inMatrixReal, double** inMatrixImag, int numRows, int numCols, double* *outReal, double * *outImag, int *outLength);</span>
<a name="l01125"></a>01125 <span class="comment">//</span>
<a name="l01127"></a>01127 <span class="comment"></span><span class="comment">//</span>
<a name="l01128"></a>01128 <span class="comment">//The LAPACK method dgeqp3 is used followed by an orthonormalization of Q through the use of DORGQR.</span>
<a name="l01129"></a>01129 <span class="comment">//The factorized form is:</span>
<a name="l01130"></a>01130 <span class="comment">//</span>
<a name="l01131"></a>01131 <span class="comment">//\par</span>
<a name="l01132"></a>01132 <span class="comment">//A = Q * R</span>
<a name="l01133"></a>01133 <span class="comment">//</span>
<a name="l01134"></a>01134 <span class="comment">//this method also returns the column pivots used in the P matrix.</span>
<a name="l01135"></a>01135 <span class="comment">//</span>
<a name="l01136"></a>01136 <span class="comment">//\param inMatrix real matrix to factorize</span>
<a name="l01137"></a>01137 <span class="comment">//\param numRows number of rows of the matrix</span>
<a name="l01138"></a>01138 <span class="comment">//\param numCols number of columns of the matrix</span>
<a name="l01139"></a>01139 <span class="comment">//\param outQ pointer to a real matrix where Q will be written</span>
<a name="l01140"></a>01140 <span class="comment">//\param outQRows number of rows of the Q matrix</span>
<a name="l01141"></a>01141 <span class="comment">//\param outQCols number of columns of the Q matrix</span>
<a name="l01142"></a>01142 <span class="comment">//\param outR pointer to a real matrix where R will be written</span>
<a name="l01143"></a>01143 <span class="comment">//\param outRRows number of rows of the R matrix</span>
<a name="l01144"></a>01144 <span class="comment">//\param outRCols number of columns of the R matrix</span>
<a name="l01145"></a>01145 <span class="comment">//\param outP pointer to a real matrix where P will be written</span>
<a name="l01146"></a>01146 <span class="comment">//\param outPRows number of rows of the P matrix</span>
<a name="l01147"></a>01147 <span class="comment">//\param outPCols number of columns of the P matrix</span>
<a name="l01148"></a>01148 <span class="comment">//</span>
<a name="l01149"></a>01149 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l01150"></a>01150 <span class="comment">//an error occurred</span>
<a name="l01151"></a>01151 <span class="comment">//</span>
<a name="l01152"></a>01152 <span class="comment">//\remarks free outP, outQ and outR using ::LibLA_freeMatrix</span>
<a name="l01153"></a>01153 <span class="comment">//</span>
<a name="l01154"></a>01154 <span class="comment">//*/</span>
<a name="l01155"></a>01155 <span class="comment">//LIB_EXTERN int LibLA_getQRWithPivot(double** inMatrix, int numRows, int numCols,</span>
<a name="l01156"></a>01156 <span class="comment">//                                    double** *outQ, int *outQRows, int * outQCols,</span>
<a name="l01157"></a>01157 <span class="comment">//                                    double** *outR, int *outRRows, int * outRCols,</span>
<a name="l01158"></a>01158 <span class="comment">//                                    double** *outP, int *outPRows, int * outPCols);</span>
<a name="l01159"></a>01159 <span class="comment">//</span>
<a name="l01161"></a>01161 <span class="comment"></span><span class="comment">//</span>
<a name="l01162"></a>01162 <span class="comment">//The LAPACK method dgeqp3 is used followed by an orthonormalization of Q through the use of DORGQR.</span>
<a name="l01163"></a>01163 <span class="comment">//The factorized form is:</span>
<a name="l01164"></a>01164 <span class="comment">//</span>
<a name="l01165"></a>01165 <span class="comment">//\par</span>
<a name="l01166"></a>01166 <span class="comment">//A = Q * R</span>
<a name="l01167"></a>01167 <span class="comment">//</span>
<a name="l01168"></a>01168 <span class="comment">//\param inMatrix real matrix to factorize</span>
<a name="l01169"></a>01169 <span class="comment">//\param numRows number of rows of the matrix</span>
<a name="l01170"></a>01170 <span class="comment">//\param numCols number of columns of the matrix</span>
<a name="l01171"></a>01171 <span class="comment">//\param outQ pointer to a real matrix where Q will be written</span>
<a name="l01172"></a>01172 <span class="comment">//\param outQRows number of rows of the Q matrix</span>
<a name="l01173"></a>01173 <span class="comment">//\param outQCols number of columns of the Q matrix</span>
<a name="l01174"></a>01174 <span class="comment">//\param outR pointer to a real matrix where R will be written</span>
<a name="l01175"></a>01175 <span class="comment">//\param outRRows number of rows of the R matrix</span>
<a name="l01176"></a>01176 <span class="comment">//\param outRCols number of columns of the R matrix</span>
<a name="l01177"></a>01177 <span class="comment">//</span>
<a name="l01178"></a>01178 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l01179"></a>01179 <span class="comment">//an error occurred</span>
<a name="l01180"></a>01180 <span class="comment">//</span>
<a name="l01181"></a>01181 <span class="comment">//\remarks free outQ and outR using ::LibLA_freeMatrix</span>
<a name="l01182"></a>01182 <span class="comment">//</span>
<a name="l01183"></a>01183 <span class="comment">//*/</span>
<a name="l01184"></a>01184 <span class="comment">//LIB_EXTERN int LibLA_getQR(double** inMatrix, int numRows, int numCols,</span>
<a name="l01185"></a>01185 <span class="comment">//                           double** *outQ, int *outQRows, int * outQCols,</span>
<a name="l01186"></a>01186 <span class="comment">//                           double** *outR, int *outRRows, int * outRCols);</span>
<a name="l01187"></a>01187 <span class="comment">//</span>
<a name="l01189"></a>01189 <span class="comment"></span><span class="comment">//</span>
<a name="l01190"></a>01190 <span class="comment">//This procedure is carried out by the LAPACK method dgesdd.</span>
<a name="l01191"></a>01191 <span class="comment">//</span>
<a name="l01192"></a>01192 <span class="comment">//\param inMatrix real matrix</span>
<a name="l01193"></a>01193 <span class="comment">//\param numRows number of rows of the matrix</span>
<a name="l01194"></a>01194 <span class="comment">//\param numCols number of columns of the matrix</span>
<a name="l01195"></a>01195 <span class="comment">//</span>
<a name="l01196"></a>01196 <span class="comment">//\param outSingularVals pointer to the double array where the singular values will be stored</span>
<a name="l01197"></a>01197 <span class="comment">//\param outLength number of singular values</span>
<a name="l01198"></a>01198 <span class="comment">//</span>
<a name="l01199"></a>01199 <span class="comment">//\return The return value will be zero (0) when successful, and negative (-1) in case</span>
<a name="l01200"></a>01200 <span class="comment">//an error occurred</span>
<a name="l01201"></a>01201 <span class="comment">//</span>
<a name="l01202"></a>01202 <span class="comment">//\remarks free outSingularVals using ::LibLA_freeVector</span>
<a name="l01203"></a>01203 <span class="comment">//*/</span>
<a name="l01204"></a>01204 <span class="comment">//</span>
<a name="l01205"></a>01205 <span class="comment">//LIB_EXTERN int LibLA_getSingularValsBySVD(double** inMatrix, int numRows, int numCols, double* *outSingularVals, int *outLength);</span>
<a name="l01206"></a>01206 <span class="comment">//</span>
<a name="l01208"></a>01208 <span class="comment"></span><span class="comment">//</span>
<a name="l01209"></a>01209 <span class="comment">//This procedure is carried out by the LAPACK method dgetc2.</span>
<a name="l01210"></a>01210 <span class="comment">//</span>
<a name="l01211"></a>01211 <span class="comment">//A is factorized into:</span>
<a name="l01212"></a>01212 <span class="comment">//</span>
<a name="l01213"></a>01213 <span class="comment">//\par</span>
<a name="l01214"></a>01214 <span class="comment">//A = P * L * U * Q</span>
<a name="l01215"></a>01215 <span class="comment">//</span>
<a name="l01216"></a>01216 <span class="comment">//Here P and Q are permutation matrices for the rows and columns respectively.</span>
<a name="l01217"></a>01217 <span class="comment">//</span>
<a name="l01218"></a>01218 <span class="comment">//\remarks This function supports only square matrices (N-by-N), choose ::LibLA_getQRWithPivot for a stable method</span>
<a name="l01219"></a>01219 <span class="comment">//operating on N-by-M matrices.</span>
<a name="l01220"></a>01220 <span class="comment">//*/</span>
<a name="l01221"></a>01221 <span class="comment">//LIB_EXTERN int LibLA_getLUwithFullPivoting(double** inMatrix, int numRows, int numCols,</span>
<a name="l01222"></a>01222 <span class="comment">//                                           double** *outL, int *outLRows, int * outLCols,</span>
<a name="l01223"></a>01223 <span class="comment">//                                           double** *outU, int *outURows, int * outUCols,</span>
<a name="l01224"></a>01224 <span class="comment">//                                           int** *outP, int *outPRows, int * outPCols,</span>
<a name="l01225"></a>01225 <span class="comment">//                                           int** *outQ, int *outQRows, int * outQCols,</span>
<a name="l01226"></a>01226 <span class="comment">//                                           int *info);</span>
<a name="l01227"></a>01227 <span class="comment">//</span>
<a name="l01229"></a>01229 <span class="comment"></span><span class="comment">//</span>
<a name="l01230"></a>01230 <span class="comment">//using partial pivoting with row interchanges. This procedure is carried out by the</span>
<a name="l01231"></a>01231 <span class="comment">//LAPACK method dgetrf.</span>
<a name="l01232"></a>01232 <span class="comment">//</span>
<a name="l01233"></a>01233 <span class="comment">//A is factorized into:</span>
<a name="l01234"></a>01234 <span class="comment">//</span>
<a name="l01235"></a>01235 <span class="comment">//\par</span>
<a name="l01236"></a>01236 <span class="comment">//A = P * L * U</span>
<a name="l01237"></a>01237 <span class="comment">//</span>
<a name="l01238"></a>01238 <span class="comment">//Here P is the row permutation matrix.</span>
<a name="l01239"></a>01239 <span class="comment">//*/</span>
<a name="l01240"></a>01240 <span class="comment">//LIB_EXTERN int LibLA_getLU(double** inMatrix, int numRows, int numCols,</span>
<a name="l01241"></a>01241 <span class="comment">//                           double** *outL, int *outLRows, int * outLCols,</span>
<a name="l01242"></a>01242 <span class="comment">//                           double** *outU, int *outURows, int * outUCols,</span>
<a name="l01243"></a>01243 <span class="comment">//                           int** *outP, int *outPRows, int * outPCols,</span>
<a name="l01244"></a>01244 <span class="comment">//                           int *info);</span>
<a name="l01245"></a>01245 <span class="comment">//</span>
<a name="l01247"></a>01247 <span class="comment"></span><span class="comment">//</span>
<a name="l01248"></a>01248 <span class="comment">//This procedure is carried out by the LAPACK methods dgetrf and dgetri. This means that the matrix will be</span>
<a name="l01249"></a>01249 <span class="comment">//factorized using LU decomposition first, followed by the calculation of the inverse based on:</span>
<a name="l01250"></a>01250 <span class="comment">//</span>
<a name="l01251"></a>01251 <span class="comment">//\par</span>
<a name="l01252"></a>01252 <span class="comment">//inv(A)*L = inv(U) for inv(A).</span>
<a name="l01253"></a>01253 <span class="comment">//*/</span>
<a name="l01254"></a>01254 <span class="comment">//LIB_EXTERN int LibLA_inverse(double** inMatrix, int numRows, int numCols,</span>
<a name="l01255"></a>01255 <span class="comment">//                             double** *outMatrix, int *outRows, int *outCols);</span>
<a name="l01256"></a>01256 <span class="comment">//</span>
<a name="l01258"></a>01258 <span class="comment"></span><span class="comment">//</span>
<a name="l01259"></a>01259 <span class="comment">//That is:</span>
<a name="l01260"></a>01260 <span class="comment">//\par</span>
<a name="l01261"></a>01261 <span class="comment">//null(A)*A = 0</span>
<a name="l01262"></a>01262 <span class="comment">//</span>
<a name="l01263"></a>01263 <span class="comment">//\remarks This function is equivalent to returning the right null space of the transposed matrix.</span>
<a name="l01264"></a>01264 <span class="comment">//See ::LibLA_rightNullspace</span>
<a name="l01265"></a>01265 <span class="comment">//*/</span>
<a name="l01266"></a>01266 <span class="comment">//LIB_EXTERN int LibLA_leftNullspace(double** inMatrix, int numRows, int numCols,</span>
<a name="l01267"></a>01267 <span class="comment">//                                   double** *outMatrix, int *outRows, int *outCols);</span>
<a name="l01268"></a>01268 <span class="comment">//</span>
<a name="l01270"></a>01270 <span class="comment"></span><span class="comment">//</span>
<a name="l01271"></a>01271 <span class="comment">//That is:</span>
<a name="l01272"></a>01272 <span class="comment">//</span>
<a name="l01273"></a>01273 <span class="comment">//\par</span>
<a name="l01274"></a>01274 <span class="comment">//A*null(A) = 0</span>
<a name="l01275"></a>01275 <span class="comment">//</span>
<a name="l01276"></a>01276 <span class="comment">//In order to calculate the (right) null space, we first calculate the full singular value decomposition (employing dgesdd) of the matrix:</span>
<a name="l01277"></a>01277 <span class="comment">//</span>
<a name="l01278"></a>01278 <span class="comment">//\par</span>
<a name="l01279"></a>01279 <span class="comment">//[U,S,V] = svd(A&#39;);</span>
<a name="l01280"></a>01280 <span class="comment">//</span>
<a name="l01281"></a>01281 <span class="comment">//then calculate the rank:</span>
<a name="l01282"></a>01282 <span class="comment">//</span>
<a name="l01283"></a>01283 <span class="comment">//\par</span>
<a name="l01284"></a>01284 <span class="comment">//r = rank(A)</span>
<a name="l01285"></a>01285 <span class="comment">//</span>
<a name="l01286"></a>01286 <span class="comment">//and finally return the last columns of the U matrix (r+1...n) as the null space matrix.</span>
<a name="l01287"></a>01287 <span class="comment">//*/</span>
<a name="l01288"></a>01288 <span class="comment">//LIB_EXTERN int LibLA_rightNullspace(double** inMatrix, int numRows, int numCols,</span>
<a name="l01289"></a>01289 <span class="comment">//                                    double** *outMatrix, int *outRows, int *outCols);</span>
<a name="l01290"></a>01290 <span class="comment">//</span>
<a name="l01292"></a>01292 <span class="comment"></span><span class="comment">//</span>
<a name="l01293"></a>01293 <span class="comment">//This function is equivalent to calling ::LibLA_leftNullspace however the resulting</span>
<a name="l01294"></a>01294 <span class="comment">//matrix will be scaled (employing Gauss Jordan factorization) to yield whole numbered</span>
<a name="l01295"></a>01295 <span class="comment">//entries wherever possible.</span>
<a name="l01296"></a>01296 <span class="comment">//*/</span>
<a name="l01297"></a>01297 <span class="comment">//LIB_EXTERN int LibLA_scaledLeftNullspace(double** inMatrix, int numRows, int numCols,</span>
<a name="l01298"></a>01298 <span class="comment">//                                         double** *outMatrix, int *outRows, int *outCols);</span>
<a name="l01299"></a>01299 <span class="comment">//</span>
<a name="l01301"></a>01301 <span class="comment"></span><span class="comment">//</span>
<a name="l01302"></a>01302 <span class="comment">//This function is equivalent to calling ::LibLA_rightNullspace however the resulting</span>
<a name="l01303"></a>01303 <span class="comment">//matrix will be scaled (employing Gauss Jordan factorization) to yield whole numbered</span>
<a name="l01304"></a>01304 <span class="comment">//entries wherever possible.</span>
<a name="l01305"></a>01305 <span class="comment">//*/</span>
<a name="l01306"></a>01306 <span class="comment">//LIB_EXTERN int LibLA_scaledRightNullspace(double** inMatrix, int numRows, int numCols,</span>
<a name="l01307"></a>01307 <span class="comment">//                                          double** *outMatrix, int *outRows, int *outCols);</span>
<a name="l01308"></a>01308 <span class="comment">//</span>
<a name="l01309"></a>01309 <span class="comment">//</span>
<a name="l01311"></a>01311 <span class="comment"></span><span class="comment">//</span>
<a name="l01312"></a>01312 <span class="comment">//The singular values of the matrix are calculated and the rank is determined by the number of non-zero values.</span>
<a name="l01313"></a>01313 <span class="comment">//</span>
<a name="l01314"></a>01314 <span class="comment">//Note that zero here is defined as any value whose absolute value is bigger than the set tolerance (see</span>
<a name="l01315"></a>01315 <span class="comment">//::LibLA_setTolerance )</span>
<a name="l01316"></a>01316 <span class="comment">//*/</span>
<a name="l01317"></a>01317 <span class="comment">//LIB_EXTERN int LibLA_getRank(double** inMatrix, int numRows, int numCols);</span>
<a name="l01318"></a>01318 <span class="comment">//</span>
<a name="l01320"></a>01320 <span class="comment"></span><span class="comment">//</span>
<a name="l01321"></a>01321 <span class="comment">//returns an estimate for the reciprocal of the condition of A in 1-norm using the LAPACK condition estimator.</span>
<a name="l01322"></a>01322 <span class="comment">//If A is well conditioned, getRCond(A) is near 1.0. If A is badly conditioned, getRCond(A) is near 0.0.</span>
<a name="l01323"></a>01323 <span class="comment">//</span>
<a name="l01324"></a>01324 <span class="comment">//*/</span>
<a name="l01325"></a>01325 <span class="comment">//LIB_EXTERN double LibLA_getRCond(double** inMatrix, int numRows, int numCols);</span>
<a name="l01326"></a>01326 <span class="comment">//</span>
<a name="l01328"></a>01328 <span class="comment"></span><span class="comment">//</span>
<a name="l01329"></a>01329 <span class="comment">//Only row swaps are used. These permutations will be returned in the &#39;pivots&#39; vector.</span>
<a name="l01330"></a>01330 <span class="comment">//</span>
<a name="l01331"></a>01331 <span class="comment">//If no permutations have occurred this vector will be in ascending form [ 0, 1, 2, 3 ];</span>
<a name="l01332"></a>01332 <span class="comment">//However if say row one and three would be swapped this vector would look like: [ 0, 3, 2, 1 ];</span>
<a name="l01333"></a>01333 <span class="comment">//</span>
<a name="l01334"></a>01334 <span class="comment">//*/</span>
<a name="l01335"></a>01335 <span class="comment">//LIB_EXTERN int LibLA_gaussJordan(double** inMatrix, int numRows, int numCols,</span>
<a name="l01336"></a>01336 <span class="comment">//                                 double** *outMatrix, int *outRows, int *outCols,</span>
<a name="l01337"></a>01337 <span class="comment">//                                 int* *oPivots, int *nLength);</span>
<a name="l01338"></a>01338 <span class="comment">//</span>
<a name="l01340"></a>01340 <span class="comment"></span><span class="comment">//</span>
<a name="l01341"></a>01341 <span class="comment">//Fully pivoted means, that rows as well as column swaps will be used. These permutations</span>
<a name="l01342"></a>01342 <span class="comment">//are captured in the integer vectors rowPivots and colPivots.</span>
<a name="l01343"></a>01343 <span class="comment">//</span>
<a name="l01344"></a>01344 <span class="comment">//If no permutations have occurred those vectors will be in ascending form [ 0, 1, 2, 3 ];</span>
<a name="l01345"></a>01345 <span class="comment">//However if say row one and three would be swapped this vector would look like: [ 0, 3, 2, 1 ];</span>
<a name="l01346"></a>01346 <span class="comment">//*/</span>
<a name="l01347"></a>01347 <span class="comment">//LIB_EXTERN int LibLA_fullyPivotedGaussJordan(double** inMatrix, int numRows, int numCols,</span>
<a name="l01348"></a>01348 <span class="comment">//                                             double** *outMatrix, int *outRows, int *outCols,</span>
<a name="l01349"></a>01349 <span class="comment">//                                             int* *oRowPivots, int *nRowLength,</span>
<a name="l01350"></a>01350 <span class="comment">//                                             int* *oColPivots, int *nColLength);</span>
<a name="l01351"></a>01351 <span class="comment">//</span>
<a name="l01352"></a>01352 <span class="comment">//</span>
<a name="l01353"></a>01353 <span class="comment">//</span>
<a name="l01355"></a>01355 <span class="comment"></span><span class="comment">//</span>
<a name="l01356"></a>01356 <span class="comment">//This procedure is carried out by the LAPACK methods: zgetrf and zgetri. This means that the matrix will be</span>
<a name="l01357"></a>01357 <span class="comment">//factorized using LU decomposition first, followed by the calculation of the inverse based on:</span>
<a name="l01358"></a>01358 <span class="comment">//</span>
<a name="l01359"></a>01359 <span class="comment">//\par</span>
<a name="l01360"></a>01360 <span class="comment">//inv(A)*L = inv(U) for inv(A).</span>
<a name="l01361"></a>01361 <span class="comment">//*/</span>
<a name="l01362"></a>01362 <span class="comment">//LIB_EXTERN int LibLA_Zinverse(double** inMatrixReal, double **inMatrixImag, int numRows, int numCols,</span>
<a name="l01363"></a>01363 <span class="comment">//                              double** *outMatrixReal, double ** *outMatrixImag, int *outRows, int *outCols);</span>
<a name="l01364"></a>01364 <span class="comment">//</span>
<a name="l01366"></a>01366 <span class="comment"></span><span class="comment">//LIB_EXTERN void LibLA_freeVector(void* vector);</span>
<a name="l01367"></a>01367 <span class="comment">//</span>
<a name="l01369"></a>01369 <span class="comment"></span><span class="comment">//LIB_EXTERN void LibLA_freeMatrix(void** matrix, int numRows);</span>
<a name="l01370"></a>01370 <span class="comment">//</span>
<a name="l01371"></a>01371 <span class="comment">//</span>
<a name="l01373"></a>01373 <span class="comment"></span><span class="comment">//</span>
<a name="l01374"></a>01374 <span class="comment">//This function calculates the complex (right)eigenvectors of the given real matrix. The complex matrix</span>
<a name="l01375"></a>01375 <span class="comment">//returned contains the eigenvectors in the columns, in the same order as LibLA_getEigenValues.</span>
<a name="l01376"></a>01376 <span class="comment">//</span>
<a name="l01377"></a>01377 <span class="comment">//The right eigenvector v(j) of A satisfies:</span>
<a name="l01378"></a>01378 <span class="comment">//\par</span>
<a name="l01379"></a>01379 <span class="comment">//A * v(j) = lambda(j) * v(j)</span>
<a name="l01380"></a>01380 <span class="comment">//</span>
<a name="l01381"></a>01381 <span class="comment">//</span>
<a name="l01382"></a>01382 <span class="comment">//*/</span>
<a name="l01383"></a>01383 <span class="comment">//LIB_EXTERN int LibLA_getEigenVectors(double** inMatrix, int numRows, int numCols,</span>
<a name="l01384"></a>01384 <span class="comment">//                                     double** *outMatrixReal, double** *outMatrixImag, int *outRows, int *outCols);</span>
<a name="l01386"></a>01386 <span class="comment"></span><span class="comment">//</span>
<a name="l01387"></a>01387 <span class="comment">//This function calculates the complex (right)eigenvectors of the given real matrix. The complex matrix</span>
<a name="l01388"></a>01388 <span class="comment">//returned contains the eigenvectors in the columns, in the same order as LibLA_ZgetEigenValues.</span>
<a name="l01389"></a>01389 <span class="comment">//The right eigenvector v(j) of A satisfies:</span>
<a name="l01390"></a>01390 <span class="comment">//\par</span>
<a name="l01391"></a>01391 <span class="comment">//A * v(j) = lambda(j) * v(j)</span>
<a name="l01392"></a>01392 <span class="comment">//</span>
<a name="l01393"></a>01393 <span class="comment">//</span>
<a name="l01394"></a>01394 <span class="comment">//*/</span>
<a name="l01395"></a>01395 <span class="comment">//LIB_EXTERN int LibLA_ZgetEigenVectors(double** inMatrixReal,   double **  inMatrixImag, int numRows, int numCols,</span>
<a name="l01396"></a>01396 <span class="comment">//                                       double** *outMatrixReal, double** *outMatrixImag, int *outRows, int *outCols);</span>
<a name="l01398"></a>01398 <span class="comment"></span><span class="comment">//</span>
<a name="l01399"></a>01399 <span class="comment">//This function computes the singular value decomposition (SVD) of the given real matrix.</span>
<a name="l01400"></a>01400 <span class="comment">//</span>
<a name="l01401"></a>01401 <span class="comment">//</span>
<a name="l01402"></a>01402 <span class="comment">//The SVD is written</span>
<a name="l01403"></a>01403 <span class="comment">//</span>
<a name="l01404"></a>01404 <span class="comment">//\par</span>
<a name="l01405"></a>01405 <span class="comment">//A = U * SIGMA * transpose(V)</span>
<a name="l01406"></a>01406 <span class="comment">//</span>
<a name="l01407"></a>01407 <span class="comment">//\remarks this function returns the transpose of V</span>
<a name="l01408"></a>01408 <span class="comment">//</span>
<a name="l01409"></a>01409 <span class="comment">//*/</span>
<a name="l01410"></a>01410 <span class="comment">//LIB_EXTERN int LibLA_getSVD(double** inMatrix, int numRows, int numCols,</span>
<a name="l01411"></a>01411 <span class="comment">//                       double** *outU, int *outRowsU, int *outColsU,</span>
<a name="l01412"></a>01412 <span class="comment">//                       double* *outSingVals, int *outLength,</span>
<a name="l01413"></a>01413 <span class="comment">//                       double** *outV, int *outRowsV, int *outColsV);</span>
<a name="l01414"></a>01414 <span class="comment">//</span>
<a name="l01416"></a>01416 <span class="comment"></span><span class="comment">//</span>
<a name="l01417"></a>01417 <span class="comment">//This function computes the singular value decomposition (SVD) of the given complex matrix.</span>
<a name="l01418"></a>01418 <span class="comment">//</span>
<a name="l01419"></a>01419 <span class="comment">//</span>
<a name="l01420"></a>01420 <span class="comment">//The SVD is written</span>
<a name="l01421"></a>01421 <span class="comment">//</span>
<a name="l01422"></a>01422 <span class="comment">//\par</span>
<a name="l01423"></a>01423 <span class="comment">//A = U * SIGMA * conjugate-transpose(V)</span>
<a name="l01424"></a>01424 <span class="comment">//</span>
<a name="l01425"></a>01425 <span class="comment">//\remarks this function returns the conjugate-transpose of V</span>
<a name="l01426"></a>01426 <span class="comment">//</span>
<a name="l01427"></a>01427 <span class="comment">//*/</span>
<a name="l01428"></a>01428 <span class="comment">//LIB_EXTERN int LibLA_ZgetSVD(double** inMatrixReal, double** inMatrixImag, int numRows, int numCols,</span>
<a name="l01429"></a>01429 <span class="comment">//                       double** *outUReal, double** *outUImag, int *outRowsU, int *outColsU,</span>
<a name="l01430"></a>01430 <span class="comment">//                       double* *outSingVals, int *outLength,</span>
<a name="l01431"></a>01431 <span class="comment">//                       double** *outVReal, double** *outVImag, int *outRowsV, int *outColsV);</span>
<a name="l01432"></a>01432 <span class="comment">//</span>
<a name="l01433"></a>01433 <span class="comment">//END_C_DECLS;</span>
<a name="l01434"></a>01434 <span class="comment">//</span>
<a name="l01435"></a>01435 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 5 2012 11:46:58 for RoadRunner C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
